/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;
import java.io.BufferedWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import org.json.*;

public class DistributionRow extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(DistributionRow.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  double [] row;
  int [] indexVector;

  /** if no arg, assume from db **/
  public DistributionRow() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public DistributionRow(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public DistributionRow(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public double [] getRow() {
    return row;
  }
  public int getId() {
    return id;
  }
  public int [] getIndexVector() {
    return indexVector;
  }
  public void setRow (double [] a_row) {
    row = a_row;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
        DistributionRowManager.getInstance().putInCache(this);
      }
  }
  public void setIndexVector (int [] a_indexVector) {
    indexVector = a_indexVector;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof DistributionRow)) //covers o == null case
      return false;
    DistributionRow other = (DistributionRow)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "DistributionRow");
      jsonObj.put("id", id);
      if (getRow() != null) {
        JSONArray rowArray = new JSONArray();
        for (double  item : getRow()) {
          rowArray.put(item);
        }
        jsonObj.put("row", rowArray);
      }
      jsonObj.put("id", getId());
      if (getIndexVector() != null) {
        JSONArray indexVectorArray = new JSONArray();
        for (int  item : getIndexVector()) {
          indexVectorArray.put(item);
        }
        jsonObj.put("indexVector", indexVectorArray);
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "DistributionRow");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getRow() != null) {
        JSONArray rowArray = new JSONArray();
        for (double  item : getRow()) {
          rowArray.put(item);
        }
        jsonObj.put("row", rowArray);
      }
      jsonObj.put("id", getId());
      if (getIndexVector() != null) {
        JSONArray indexVectorArray = new JSONArray();
        for (int  item : getIndexVector()) {
          indexVectorArray.put(item);
        }
        jsonObj.put("indexVector", indexVectorArray);
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray rowArray = jsonObj.optJSONArray("row");
      if (rowArray != null) {
        double[] aRow = new double[rowArray.length()];
        for (int i = 0; i < rowArray.length(); i++) {
          aRow[i] = rowArray.getDouble(i);
        }
        setRow(aRow);
      }
      JSONArray indexVectorArray = jsonObj.optJSONArray("indexVector");
      if (indexVectorArray != null) {
        int[] aIndexVector = new int[indexVectorArray.length()];
        for (int i = 0; i < indexVectorArray.length(); i++) {
          aIndexVector[i] = indexVectorArray.getInt(i);
        }
        setIndexVector(aIndexVector);
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  public static DistributionRow newRow(int [] a_indexVector, double [] a_row) {
    DistributionRow row = new DistributionRow();
    row.setIndexVector(a_indexVector);
    row.setRow(a_row);
    return row;
  }
  
  public String indexVectorAsString() {
    StringBuffer sb = new StringBuffer();
    sb.append('[');
    if (getIndexVector() != null) {
      for (int i = 0; i < getIndexVector().length; i++) {
        if (i > 0) {
          sb.append(' ');
        }
        sb.append(getIndexVector()[i]);
      }
    }
    sb.append(']');
    return sb.toString();
  }
  
  public boolean caseMatch(int [] a_indexVector) {
    int [] iv = getIndexVector();
    if (iv.length == 0 && (a_indexVector == null || a_indexVector.length == 0)) {
      return true;
    }
    if (a_indexVector == null || a_indexVector.length != iv.length) {
      return false;
    }
    for (int i = 0; i < iv.length; i++) {
      if (a_indexVector[i] != iv[i]) {
        return false;
      }
    }
    return true;
  }
  
  public double normalize() {
    double norm = 0;
    for (int i = 0; i < row.length; i++) {
      norm += row[i];
    }
    if (norm > 0.0) {
      for (int i = 0; i < row.length; i++) {
        row[i] /= norm;
      }
    }
    return norm;
  }

  public double zero() {
    for (int i = 0; i < row.length; i++) {
      row[i] = 0.0;
    }
    return 0.0;
  }

  public long export(BufferedWriter writer, JSONObject json, HashMap <Object, Long> objectIndex) 
      throws IOException, JSONException {
    if (objectIndex.containsKey(this)) {
      return objectIndex.get(this);
    } else {
      long rowId = GraphTMP.nextJSONId();
      objectIndex.put(this, rowId);
      JSONObject rowJSON = asJSON();
      JSONArray jsonRows = new JSONArray();
      //if (getHasDistributionRows() != null) {
      //  for (DistributionRow row: getHasDistributionRows()) {
      //jsonDistributions.put(dist.export(writer, dictionary, localDictionary));
      // }
      // distJSON.put("hasDistributions", jsonRows);
      json.put(""+rowId, rowJSON);
      //}
      return rowId;
    }
  }


}
