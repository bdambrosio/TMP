/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;
import java.io.BufferedWriter;
import java.io.IOException;
import java.util.HashMap;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

public class Node extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(Node.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  int order;
  protected ArrayList<Distribution> hasDistributions = new ArrayList<Distribution>(0);

  public void setHasDistributionsRawValueInternal(String rawVal) {
  }

  protected ArrayList<Distribution> CachedLambdas = new ArrayList<Distribution>(0);

  public void setCachedLambdasRawValueInternal(String rawVal) {
  }

  String [] domain;
  protected Distribution cachedPi = null;

  protected Distribution cachedPosterior = null;

  int evidence;
  protected ArrayList<Distribution> model = new ArrayList<Distribution>(0);

  public void setModelRawValueInternal(String rawVal) {
  }

  String hasName;

  /** if no arg, assume from db **/
  public Node() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public Node(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public Node(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public int getOrder() {
    return order;
  }
  public boolean hasDistributionsAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsHasDistributions(Distribution value) {
      return hasDistributions.contains(value);
  }

  public ArrayList<Distribution> getHasDistributions() {
      return hasDistributions;
  }
  public boolean CachedLambdasAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsCachedLambdas(Distribution value) {
      return CachedLambdas.contains(value);
  }

  public ArrayList<Distribution> getCachedLambdas() {
      return CachedLambdas;
  }
  public String [] getDomain() {
    return domain;
  }
  public boolean CachedPiIsResident() {
      return true;
  }
  public Distribution getCachedPi() {

    return cachedPi;
  }
  public int getCachedPiInternalId() {
    if (cachedPi == null) {
      return -1;
    } else { 
      return cachedPi.getId();
    }
  }
  public int getId() {
    return id;
  }
  public boolean CachedPosteriorIsResident() {
      return true;
  }
  public Distribution getCachedPosterior() {

    return cachedPosterior;
  }
  public int getCachedPosteriorInternalId() {
    if (cachedPosterior == null) {
      return -1;
    } else { 
      return cachedPosterior.getId();
    }
  }
  public int getEvidence() {
    return evidence;
  }
  public boolean modelAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsModel(Distribution value) {
      return model.contains(value);
  }

  public ArrayList<Distribution> getModel() {
      return model;
  }
  public String getHasName() {
    return hasName;
  }
  public void setOrder (int a_order) {
    order = a_order;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasDistributions(Collection<Distribution> newHasDistributions) {
    hasDistributions=new ArrayList<Distribution>(newHasDistributions);
  }

  public void add1HasDistributions(Distribution newHasDistributions) {
    hasDistributions.add(newHasDistributions);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasDistributions(Collection<Distribution> newHasDistributions) {
    hasDistributions.addAll(newHasDistributions);
  }

  public boolean remove1HasDistributions(Distribution newHasDistributions) {
    return hasDistributions.remove(newHasDistributions);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setCachedLambdas(Collection<Distribution> newCachedLambdas) {
    CachedLambdas=new ArrayList<Distribution>(newCachedLambdas);
  }

  public void add1CachedLambdas(Distribution newCachedLambdas) {
    CachedLambdas.add(newCachedLambdas);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllCachedLambdas(Collection<Distribution> newCachedLambdas) {
    CachedLambdas.addAll(newCachedLambdas);
  }

  public boolean remove1CachedLambdas(Distribution newCachedLambdas) {
    return CachedLambdas.remove(newCachedLambdas);
  }
  public void setDomain (String [] a_domain) {
    domain = a_domain;
  }

  public void setCachedPi(Distribution newCachedPi) {
    cachedPi = newCachedPi;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
        NodeManager.getInstance().putInCache(this);
      }
  }

  public void setCachedPosterior(Distribution newCachedPosterior) {
    cachedPosterior = newCachedPosterior;
  }
  public void setEvidence (int a_evidence) {
    evidence = a_evidence;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setModel(Collection<Distribution> newModel) {
    model=new ArrayList<Distribution>(newModel);
  }

  public void add1Model(Distribution newModel) {
    model.add(newModel);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllModel(Collection<Distribution> newModel) {
    model.addAll(newModel);
  }

  public boolean remove1Model(Distribution newModel) {
    return model.remove(newModel);
  }
  public void setHasName (String a_hasName) {
    hasName = a_hasName;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof Node)) //covers o == null case
      return false;
    Node other = (Node)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Node");
      jsonObj.put("id", id);
      jsonObj.put("order", getOrder());
       if (getHasDistributions() != null) {
         String HasDistributionsAsString = "";
         for (Distribution HasDistributionsitem: getHasDistributions()) {
           HasDistributionsAsString += HasDistributionsitem.getId() + ",";
           HasDistributionsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasDistributions", HasDistributionsAsString);
       }
       if (getCachedLambdas() != null) {
         String CachedLambdasAsString = "";
         for (Distribution CachedLambdasitem: getCachedLambdas()) {
           CachedLambdasAsString += CachedLambdasitem.getId() + ",";
           CachedLambdasAsString.replaceFirst(",$", "");
         }
         jsonObj.put("CachedLambdas", CachedLambdasAsString);
       }
      if (getDomain() != null) {
        JSONArray domainArray = new JSONArray();
        for (String  item : getDomain()) {
          domainArray.put(item);
        }
        jsonObj.put("domain", domainArray);
      }
      if (getCachedPi() != null) {
        jsonObj.put("cachedPi", getCachedPi().getId());
      }
      jsonObj.put("id", getId());
      if (getCachedPosterior() != null) {
        jsonObj.put("cachedPosterior", getCachedPosterior().getId());
      }
      jsonObj.put("evidence", getEvidence());
       if (getModel() != null) {
         String ModelAsString = "";
         for (Distribution Modelitem: getModel()) {
           ModelAsString += Modelitem.getId() + ",";
           ModelAsString.replaceFirst(",$", "");
         }
         jsonObj.put("model", ModelAsString);
       }
      jsonObj.put("hasName", getHasName());
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Node");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("order", getOrder());
       if (getHasDistributions() != null) {
         String HasDistributionsAsString = "";
         for (Distribution HasDistributionsitem: getHasDistributions()) {
           HasDistributionsAsString += HasDistributionsitem.getId() + ",";
           HasDistributionsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasDistributions", HasDistributionsAsString);
       }
       if (getCachedLambdas() != null) {
         String CachedLambdasAsString = "";
         for (Distribution CachedLambdasitem: getCachedLambdas()) {
           CachedLambdasAsString += CachedLambdasitem.getId() + ",";
           CachedLambdasAsString.replaceFirst(",$", "");
         }
         jsonObj.put("CachedLambdas", CachedLambdasAsString);
       }
      if (getDomain() != null) {
        JSONArray domainArray = new JSONArray();
        for (String  item : getDomain()) {
          domainArray.put(item);
        }
        jsonObj.put("domain", domainArray);
      }
      if (getCachedPi() != null) {
        jsonObj.put("cachedPi", getCachedPi().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      if (getCachedPosterior() != null) {
        jsonObj.put("cachedPosterior", getCachedPosterior().asJSONTreeAux(written));
      }
      jsonObj.put("evidence", getEvidence());
       if (getModel() != null) {
         String ModelAsString = "";
         for (Distribution Modelitem: getModel()) {
           ModelAsString += Modelitem.getId() + ",";
           ModelAsString.replaceFirst(",$", "");
         }
         jsonObj.put("model", ModelAsString);
       }
      jsonObj.put("hasName", getHasName());
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("order")) {
        setOrder(jsonObj.optInt("order"));
      }
      if (!jsonObj.isNull("hasDistributions")) {
      String [] hasDistributionsAsStrings = jsonObj.optString("hasDistributions").split(",");
      ArrayList<Distribution> hasDistributionsValues = new ArrayList<Distribution>(hasDistributionsAsStrings.length);
      for (String hasDistributionsItemId: hasDistributionsAsStrings) {
      if (hasDistributionsItemId != null && DistributionManager.getInstance().get(Integer.parseInt(hasDistributionsItemId)) != null) {
          hasDistributionsValues.add(DistributionManager.getInstance().get(Integer.parseInt(hasDistributionsItemId)));
        }
      }
      hasDistributions = hasDistributionsValues;
      }
      if (!jsonObj.isNull("CachedLambdas")) {
      String [] CachedLambdasAsStrings = jsonObj.optString("CachedLambdas").split(",");
      ArrayList<Distribution> CachedLambdasValues = new ArrayList<Distribution>(CachedLambdasAsStrings.length);
      for (String CachedLambdasItemId: CachedLambdasAsStrings) {
      if (CachedLambdasItemId != null && DistributionManager.getInstance().get(Integer.parseInt(CachedLambdasItemId)) != null) {
          CachedLambdasValues.add(DistributionManager.getInstance().get(Integer.parseInt(CachedLambdasItemId)));
        }
      }
      CachedLambdas = CachedLambdasValues;
      }
      JSONArray domainArray = jsonObj.optJSONArray("domain");
      if (domainArray != null) {
        String[] aDomain = new String[domainArray.length()];
        for (int i = 0; i < domainArray.length(); i++) {
          aDomain[i] = domainArray.getString(i);
        }
        setDomain(aDomain);
      }
      if (!jsonObj.isNull("cachedPi")) {
        int cachedPiId = jsonObj.optInt("cachedPi");
        Distribution value = DistributionManager.getInstance().get(cachedPiId);
        if(value != null) {
            setCachedPi(value);
        }
      }
      if (!jsonObj.isNull("cachedPosterior")) {
        int cachedPosteriorId = jsonObj.optInt("cachedPosterior");
        Distribution value = DistributionManager.getInstance().get(cachedPosteriorId);
        if(value != null) {
            setCachedPosterior(value);
        }
      }
      if (!jsonObj.isNull("evidence")) {
        setEvidence(jsonObj.optInt("evidence"));
      }
      if (!jsonObj.isNull("model")) {
      String [] modelAsStrings = jsonObj.optString("model").split(",");
      ArrayList<Distribution> modelValues = new ArrayList<Distribution>(modelAsStrings.length);
      for (String modelItemId: modelAsStrings) {
      if (modelItemId != null && DistributionManager.getInstance().get(Integer.parseInt(modelItemId)) != null) {
          modelValues.add(DistributionManager.getInstance().get(Integer.parseInt(modelItemId)));
        }
      }
      model = modelValues;
      }
      if (!jsonObj.isNull("hasName")) {
        setHasName(jsonObj.optString("hasName"));
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  static int nextNodeNum = 0;

  public static int nextOrder() {
    return nextNodeNum++;
  }
  
  public static Node newNode(String name) {
    Node n = new Node();
    n.setHasName(name);
    n.setOrder(nextOrder());
    n.setEvidence(-1);
    return n;
    
  }

  public static Node newNode(String a_name, String [] a_domain) {
    Node n = new Node();
    n.setHasName(a_name);
    n.setOrder(nextOrder());
    n.setDomain(a_domain);
    n.setEvidence(-1);
    return n;
    
  }
  
  public Distribution getCachedLambda(Node parent) {
    for (Distribution d_li: getCachedLambdas()) {
      if (d_li.getHasDomainNodes().size() == 1 && d_li.getHasDomainNodes().get(0) == parent) {
        return d_li;
      }
    }
    return null;
  }

  public String toString() {
    return "N"+hasName;
  }
  
  public long export(BufferedWriter writer, JSONObject json, HashMap <Object, Long> objectIndex) 
      throws IOException, JSONException {
    /* Node 1 {"hasName":"Q5","id":"51","order":50,"hasDistributions":"1389043350133325000288,","evidence":-1,"domain":["S0","S1"],"class":"Node"} */
    if (objectIndex.containsKey(this)) {
      return objectIndex.get(this);
    } else {
      long nodeId = GraphTMP.nextJSONId();
      objectIndex.put(this, nodeId);
      JSONObject nodeJSON = asJSON();
      JSONArray jsonDistributions = new JSONArray();
      if (getHasDistributions() != null) {
        for (Distribution dist: getHasDistributions()) {
          jsonDistributions.put(dist.export(writer, json, objectIndex));
        }
        nodeJSON.put("hasDistributions", jsonDistributions);
      }
      JSONArray jsonModel = new JSONArray();
      if (getModel() != null) {
        for (Distribution dist: getModel()) {
          jsonModel.put(dist.export(writer, json, objectIndex));
        }
        nodeJSON.put("model", jsonModel);
        json.put(""+nodeId, nodeJSON);
      }
      return nodeId;
    }
  }

}
