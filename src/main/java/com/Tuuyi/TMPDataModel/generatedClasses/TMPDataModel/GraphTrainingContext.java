/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class GraphTrainingContext extends  GraphContext {

  protected static final Logger logWriter = Logger.getLogger(GraphTrainingContext.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}


  /** if no arg, assume from db **/
  public GraphTrainingContext() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public GraphTrainingContext(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public GraphTrainingContext(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof GraphTrainingContext)) //covers o == null case
      return false;
    GraphTrainingContext other = (GraphTrainingContext)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "GraphTrainingContext");
      jsonObj.put("id", id);
      if (getHasSink() != null) {
        jsonObj.put("hasSink", getHasSink().getId());
      }
      jsonObj.put("id", getId());
      if (getInputBeliefspace() != null) {
        jsonObj.put("inputBeliefspace", getInputBeliefspace().getId());
      }
      jsonObj.put("propagationMark", getPropagationMark());
      if (getHasDefaultInputChannel() != null) {
        jsonObj.put("hasDefaultInputChannel", getHasDefaultInputChannel().getId());
      }
      jsonObj.put("scatterThreshold", getScatterThreshold());
      if (getOutputBeliefspace() != null) {
        jsonObj.put("outputBeliefspace", getOutputBeliefspace().getId());
      }
      if (getHasModel() != null) {
        jsonObj.put("hasModel", getHasModel().getId());
      }
      if (getOutputNamespace() != null) {
        jsonObj.put("outputNamespace", getOutputNamespace().getId());
      }
      if (getInputNamespace() != null) {
        jsonObj.put("inputNamespace", getInputNamespace().getId());
      }
      if (getHasSource() != null) {
        jsonObj.put("hasSource", getHasSource().getId());
      }
      if (getHasMapMethod() != null) {
        jsonObj.put("hasMapMethod", getHasMapMethod().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "GraphTrainingContext");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getHasSink() != null) {
        jsonObj.put("hasSink", getHasSink().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      if (getInputBeliefspace() != null) {
        jsonObj.put("inputBeliefspace", getInputBeliefspace().asJSONTreeAux(written));
      }
      jsonObj.put("propagationMark", getPropagationMark());
      if (getHasDefaultInputChannel() != null) {
        jsonObj.put("hasDefaultInputChannel", getHasDefaultInputChannel().asJSONTreeAux(written));
      }
      jsonObj.put("scatterThreshold", getScatterThreshold());
      if (getOutputBeliefspace() != null) {
        jsonObj.put("outputBeliefspace", getOutputBeliefspace().asJSONTreeAux(written));
      }
      if (getHasModel() != null) {
        jsonObj.put("hasModel", getHasModel().asJSONTreeAux(written));
      }
      if (getOutputNamespace() != null) {
        jsonObj.put("outputNamespace", getOutputNamespace().asJSONTreeAux(written));
      }
      if (getInputNamespace() != null) {
        jsonObj.put("inputNamespace", getInputNamespace().asJSONTreeAux(written));
      }
      if (getHasSource() != null) {
        jsonObj.put("hasSource", getHasSource().asJSONTreeAux(written));
      }
      if (getHasMapMethod() != null) {
        jsonObj.put("hasMapMethod", getHasMapMethod().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("hasSink")) {
        int hasSinkId = jsonObj.optInt("hasSink");
        Collector value = CollectorManager.getInstance().get(hasSinkId);
        if(value != null) {
            setHasSink(value);
        }
      }
      if (!jsonObj.isNull("inputBeliefspace")) {
        int inputBeliefspaceId = jsonObj.optInt("inputBeliefspace");
        Beliefspace value = BeliefspaceManager.getInstance().get(inputBeliefspaceId);
        if(value != null) {
            setInputBeliefspace(value);
        }
      }
      if (!jsonObj.isNull("propagationMark")) {
        setPropagationMark(jsonObj.optLong("propagationMark"));
      }
      if (!jsonObj.isNull("hasDefaultInputChannel")) {
        int hasDefaultInputChannelId = jsonObj.optInt("hasDefaultInputChannel");
        Channel value = ChannelManager.getInstance().get(hasDefaultInputChannelId);
        if(value != null) {
            setHasDefaultInputChannel(value);
        }
      }
      if (!jsonObj.isNull("scatterThreshold")) {
        setScatterThreshold(jsonObj.optDouble("scatterThreshold"));
      }
      if (!jsonObj.isNull("outputBeliefspace")) {
        int outputBeliefspaceId = jsonObj.optInt("outputBeliefspace");
        Beliefspace value = BeliefspaceManager.getInstance().get(outputBeliefspaceId);
        if(value != null) {
            setOutputBeliefspace(value);
        }
      }
      if (!jsonObj.isNull("hasModel")) {
        int hasModelId = jsonObj.optInt("hasModel");
        GraphTMP value = GraphTMPManager.getInstance().get(hasModelId);
        if(value != null) {
            setHasModel(value);
        }
      }
      if (!jsonObj.isNull("outputNamespace")) {
        int outputNamespaceId = jsonObj.optInt("outputNamespace");
        Namespace value = NamespaceManager.getInstance().get(outputNamespaceId);
        if(value != null) {
            setOutputNamespace(value);
        }
      }
      if (!jsonObj.isNull("inputNamespace")) {
        int inputNamespaceId = jsonObj.optInt("inputNamespace");
        Namespace value = NamespaceManager.getInstance().get(inputNamespaceId);
        if(value != null) {
            setInputNamespace(value);
        }
      }
      if (!jsonObj.isNull("hasSource")) {
        int hasSourceId = jsonObj.optInt("hasSource");
        Collector value = CollectorManager.getInstance().get(hasSourceId);
        if(value != null) {
            setHasSource(value);
        }
      }
      if (!jsonObj.isNull("hasMapMethod")) {
        int hasMapMethodId = jsonObj.optInt("hasMapMethod");
        Mapper value = MapperManager.getInstance().get(hasMapMethodId);
        if(value != null) {
            setHasMapMethod(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  protected Beliefspace inputSumSpace;
  protected Beliefspace outputSumSpace;
  protected Beliefspace arcSums;
  protected boolean inputKnown = true;
  protected boolean outputKnown = true; 

  /**
   * Basic training
   * Initialize: 
   *  (optional) create <unknownSetSize> unknown beliefspace, set each to 1/n? or random around 1/n?
   *  train. But, use unknown belief space posteriors as other half of training instances.
   *    (note initially this will just be random priors if we haven't initialized arc space)
   *    apply each training instance:
   *      scatter
   *      use inferred values as training instance for arcs.
   */
  
   public GraphTrainingContext (InstanceSparseGraph initGraph, boolean inputKnown, boolean outputKnown) {
     super(initGraph);
     this.inputKnown = inputKnown;
     this.outputKnown = outputKnown;
     this.inputSumSpace = new Beliefspace();
     this.outputSumSpace = new Beliefspace();
     this.arcSums = new Beliefspace();
     this.outputKnown = outputKnown;
   }
   public GraphTrainingContext  (boolean inputKnown, boolean outputKnown) {
     super(new InstanceSparseGraph());
     this.inputKnown = inputKnown;
     this.outputKnown = outputKnown;
     this.inputSumSpace = new Beliefspace();
     this.outputSumSpace = new Beliefspace();
     this.arcSums = new Beliefspace();
     this.outputKnown = outputKnown;
   }
  
  protected boolean train(InstanceSparseGraph.InstanceGraphInstance [] data) {
    return true;
  }
}
