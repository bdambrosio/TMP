/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class Abstraction extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(Abstraction.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  protected Projection hasProjection = null;


  /** if no arg, assume from db **/
  public Abstraction() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public Abstraction(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public Abstraction(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public int getId() {
    return id;
  }
  public boolean HasProjectionIsResident() {
      return true;
  }
  public Projection getHasProjection() {

    return hasProjection;
  }
  public int getHasProjectionInternalId() {
    if (hasProjection == null) {
      return -1;
    } else { 
      return hasProjection.getId();
    }
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }

  public void setHasProjection(Projection newHasProjection) {
    hasProjection = newHasProjection;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof Abstraction)) //covers o == null case
      return false;
    Abstraction other = (Abstraction)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Abstraction");
      jsonObj.put("id", id);
      jsonObj.put("id", getId());
      if (getHasProjection() != null) {
        jsonObj.put("hasProjection", getHasProjection().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Abstraction");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("id", getId());
      if (getHasProjection() != null) {
        jsonObj.put("hasProjection", getHasProjection().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("hasProjection")) {
        int hasProjectionId = jsonObj.optInt("hasProjection");
        Projection value = ProjectionManager.getInstance().get(hasProjectionId);
        if(value != null) {
            setHasProjection(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  private Abstractor abstractor;
  
  public AbstractItem abstractItem(CatalogItem item) {
    return abstractor.map(item);
  }
    
  public Abstractor getAbstractor() {
    return abstractor;
  }
  public void setAbstractor(Abstractor abstractor) {
    this.abstractor = abstractor;
  }

  public void useDefaultAbstractor() {
    this.abstractor = new Abstraction.DefaultAbstractor();
  }

  
  public Abstraction(Abstractor a) {
    abstractor = a;
  }
  
  long now = System.currentTimeMillis();
  public class DefaultAbstractor implements Abstractor {
    HashSet<String> rootCategories = new HashSet<String>();
    public AbstractItem map(CatalogItem item) {
      AbstractItem abstractItem = new AbstractItem(false);
      abstractItem.setItemId(item.getItemId());
      HashSet<MapReduceItem> abstraction = new HashSet<MapReduceItem> ();
      Iterator<String> keys = item.getRawCatalogData().keys();
      while ( keys.hasNext() ) {
        String key = keys.next();
        if (key.startsWith("Description") || key.startsWith("Content")) {
          continue;
        }
        if (key.startsWith("Title")) {
          continue;
        }
        Object value = item.getRawCatalogData().opt(key);
        if (value != null && JSONArray.class.isInstance(value)) {
          JSONArray valueArray = item.getRawCatalogData().optJSONArray(key);
          for (int i = 0; i < valueArray.length(); i++) {
            String valueArrayElement = valueArray.optString(i);
            MapReduceItem st = new MapReduceItem(key+":"+valueArrayElement, 1.0);
            abstraction.add(st);
          }
        } else if (value != null && String.class.isInstance(value)) {
          MapReduceItem st = new MapReduceItem(key+":"+value, 1.0);
          abstraction.add(st);
        } else if (value != null && Date.class.isInstance(value) && key.equals("PublicationDate")) {
          MapReduceItem st = new MapReduceItem(key+":"+(now -((Date)value).getTime())/84600000 , 1.0);
          abstraction.add(st);
        } else if (value != null) {
          logWriter.warn("Unknown data type in catalog data, skipping "+key+": "+value.getClass().getSimpleName());
        }
      }
      //[category:Sheers, Attributes:Colour.Black, category:Classic>Sheer Tights, category:Specialist>Extra Tall>5'10'' - 5'11'', 
      // Attributes:Colour.African, Brand:Levante, category:Fashion>Coloured Hosiery>Nude>Sunkissed, Attributes:Size.Small, 
      // category:Fashion>Coloured Hosiery>Nude>English Rose, category:findit>Top 10, Attributes:Colour.Asian, 
      // Title:Levante Class Tights, Attributes:Colour.English Rose, category:Specialist>Extra Tall>6'1'' +, 
      // Attributes:Size.Medium, category:findit>Sheer: 10 - 20 Denier, Attributes:Size.Tall, category:Classic, 
      // Content:These Levante Class 12 denier glossy tights are made in Italy using quality hosiery yarns and are some of the longest-lasting sheer tights around..., 
      // category:findit>Reinforced Toe, category:findit>Levante Class, category:Specialist>Extra Tall>6'0'', Attributes:Colour.Sunkissed, category:Specialist>Extra Tall, 
      // category:findit>Shiny, clientEntityId:1017, 
      // Description:These Levante Class 12 denier glossy tights are made in Italy using quality hosiery yarns and are some of the longest-lasting sheer tights around.., 
      // category:findit>Mother's Day Gift Ideas, category:Tights, category:Fashion>Coloured Hosiery>Navy, Attributes:Colour.Mediterranean, 
      // Description.length:long, category:Fashion>Coloured Hosiery>Grey, category:findit>Catalogue Sheer's, Attributes:Colour.Navy, Attributes:Size.X Tall, 
      // Attributes:Colour.Grey, category:Fashion>Coloured Hosiery>Black, 
      // PublicationDate:1277, category:Sheers>Classic Pantyhose, category:Tights>Sheer Tights]
      // first find main category to prepend to attributes      
      ArrayList<String> rootCategories = new ArrayList<String>();
      for (MapReduceItem token: abstraction) {
        if (!token.getItem().startsWith("category:")) {
          continue;
        }
        
        int colon = token.getItem().indexOf(":");
        if (colon > 0) {
          String root = token.getItem().substring(0, colon);
          String tail = token.getItem().substring(token.getItem().indexOf(":")+1);
          if (root.equalsIgnoreCase("category") && !tail.startsWith("Brand") && tail.matches("^[a-zA-Z]*$")) {
            rootCategories.add(tail);
          }
        }
      }
      // now create actual strings to be parsed. 
      ArrayList<MapReduceItem> newTokens = new ArrayList<MapReduceItem>();
      for (MapReduceItem token: abstraction) {
        if (!token.getItem().startsWith("category:") && !token.getItem().startsWith("PublicationDate") && rootCategories.size() > 0) {
          String tail = token.getItem();
          String expandedValue = "category:"+rootCategories.get(0)+";"+tail;
          token.setItem(expandedValue);
          for (int i = 1; i < rootCategories.size(); i++) {
            MapReduceItem addlToken = new MapReduceItem();
            expandedValue = "category:"+rootCategories.get(i)+";"+tail;
            addlToken.setItem(expandedValue);
            addlToken.setScore(1.0/rootCategories.size());
            newTokens.add(addlToken);
          }
        }
      }
      abstraction.addAll(newTokens);
      abstractItem.setHasAbstractionMapping(abstraction);
      return abstractItem;
    }

  }

}
