/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;
import java.io.BufferedWriter;
import java.io.IOException;

public class VTDistribution extends  Distribution {

  protected static final Logger logWriter = Logger.getLogger(VTDistribution.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}


  /** if no arg, assume from db **/
  public VTDistribution() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public VTDistribution(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public VTDistribution(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof VTDistribution)) //covers o == null case
      return false;
    VTDistribution other = (VTDistribution)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "VTDistribution");
      jsonObj.put("id", id);
      jsonObj.put("id", getId());
      if (getHasDependenceModel() != null) {
        JSONArray hasDependenceModelArray = new JSONArray();
        for (double  item : getHasDependenceModel()) {
          hasDependenceModelArray.put(item);
        }
        jsonObj.put("hasDependenceModel", hasDependenceModelArray);
      }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().getId());
      }
      if (getHasRangeNodes() != null) {
        jsonObj.put("hasRangeNodes", getHasRangeNodes().getId());
      }
      if (getHasDistributionRows() != null) {
        JSONArray jsonHasDistributionRows = new JSONArray();
        for (DistributionRow row: getHasDistributionRows()) {
          jsonHasDistributionRows.put(row.getId());
        }
        jsonObj.put("hasDistributionRows", jsonHasDistributionRows);
      }
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "VTDistribution");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("id", getId());
      if (getHasDependenceModel() != null) {
        JSONArray hasDependenceModelArray = new JSONArray();
        for (double  item : getHasDependenceModel()) {
          hasDependenceModelArray.put(item);
        }
        jsonObj.put("hasDependenceModel", hasDependenceModelArray);
      }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().asJSONTreeAux(written));
      }
      if (getHasRangeNodes() != null) {
        jsonObj.put("hasRangeNodes", getHasRangeNodes().asJSONTreeAux(written));
      }
      if (getHasDistributionRows() != null) {
        JSONArray jsonHasDistributionRows = new JSONArray();
        for (DistributionRow row: getHasDistributionRows()) {
          jsonHasDistributionRows.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasDistributionRows", jsonHasDistributionRows);
      }
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray hasDependenceModelArray = jsonObj.optJSONArray("hasDependenceModel");
      if (hasDependenceModelArray != null) {
        double[] aHasDependenceModel = new double[hasDependenceModelArray.length()];
        for (int i = 0; i < hasDependenceModelArray.length(); i++) {
          aHasDependenceModel[i] = hasDependenceModelArray.getDouble(i);
        }
        setHasDependenceModel(aHasDependenceModel);
      }
      if (!jsonObj.isNull("hasPropertySet")) {
        int hasPropertySetId = jsonObj.optInt("hasPropertySet");
        PropertySet value = PropertySetManager.getInstance().get(hasPropertySetId);
        if(value != null) {
            setHasPropertySet(value);
        }
      }
      if (!jsonObj.isNull("hasRangeNodes")) {
        int hasRangeNodesId = jsonObj.optInt("hasRangeNodes");
        NodeList value = NodeListManager.getInstance().get(hasRangeNodesId);
        if(value != null) {
            setHasRangeNodes(value);
        }
      }
      JSONArray hasDistributionRowsArray = jsonObj.optJSONArray("hasDistributionRows");
      if(hasDistributionRowsArray != null) {
        ArrayList<DistributionRow> aListOfHasDistributionRows = new ArrayList<DistributionRow>(hasDistributionRowsArray.length());
        for (int i = 0; i < hasDistributionRowsArray.length(); i++) {
          int id = hasDistributionRowsArray.optInt(i);
          if (DistributionRowManager.getInstance().get(id) != null) {
            aListOfHasDistributionRows.add(DistributionRowManager.getInstance().get(id));
          }
        }
        setHasDistributionRows(aListOfHasDistributionRows);
      }
      if (!jsonObj.isNull("hasDomainNodes")) {
        int hasDomainNodesId = jsonObj.optInt("hasDomainNodes");
        NodeList value = NodeListManager.getInstance().get(hasDomainNodesId);
        if(value != null) {
            setHasDomainNodes(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  protected ArrayList<DistributionRow> makeRows() {
    NodeList range = getHasRangeNodes();
    NodeList domain = getHasDomainNodes();
    int resultDistSize = range.distributionSize();
    ArrayList <DistributionRow> rows = new ArrayList <DistributionRow> (resultDistSize);
    for (int [] rowIndex: domain.makeRowCases()) {
      DistributionRow newRow = new DistributionRow();
      newRow.setIndexVector(rowIndex);
      newRow.setRow(new double [resultDistSize]);
      rows.add(newRow);
    }
    return rows;
  }
  
  public Distribution multiply(Distribution op2, NodeList targetNodes) {
    TwoOpIndexStructure multiplyStructure = makeMultiplyIndexStructure(op2, targetNodes);
    doMultiply(multiplyStructure);
    return multiplyStructure.getHasResult();
  }
  
  public TwoOpIndexStructure makeMultiplyIndexStructure(Distribution op2, NodeList targetNodes) {
    NodeList allNodes = getHasDomainNodes().union(getHasRangeNodes()).union(op2.getHasDomainNodes()).union(op2.getHasRangeNodes());
    NodeList cNodes = getHasDomainNodes().setDifference(op2.getHasRangeNodes()).union(op2.getHasDomainNodes().setDifference(getHasRangeNodes()));
    Distribution result = newDistribution(cNodes, allNodes.setDifference(cNodes).intersection(targetNodes));
    // make iteration steps for all three sets of rows

    TwoOpIndexStructure multStruct = new TwoOpIndexStructure();
    multStruct.setDist1(this);
    multStruct.setDist2(op2);
    multStruct.setHasResult(result);
    multStruct.setNodeIndex(0);
    multStruct.setNodes(allNodes);
    multStruct.setOp1ROffset(getHasDomainNodes().computeOffset(allNodes));
    multStruct.setOp1RSteps(getHasDomainNodes().makeSteps(allNodes));
    multStruct.setOp1COffset(getHasRangeNodes().computeOffset(allNodes));
    multStruct.setOp1CSteps(getHasRangeNodes().makeSteps(allNodes));
    multStruct.setOp2ROffset(op2.getHasDomainNodes().computeOffset(allNodes));
    multStruct.setOp2RSteps(op2.getHasDomainNodes().makeSteps(allNodes));
    multStruct.setOp2COffset(op2.getHasRangeNodes().computeOffset(allNodes));
    multStruct.setOp2CSteps(op2.getHasRangeNodes().makeSteps(allNodes));
    multStruct.setResultROffset(result.getHasDomainNodes().computeOffset(allNodes));
    multStruct.setResultRSteps(result.getHasDomainNodes().makeSteps(allNodes));
    multStruct.setResultCOffset(result.getHasRangeNodes().computeOffset(allNodes));
    multStruct.setResultCSteps(result.getHasRangeNodes().makeSteps(allNodes));
    multStruct.setOp1Rows(this.getHasDistributionRows());
    multStruct.setOp2Rows(op2.getHasDistributionRows());
    multStruct.setResultRows(result.getHasDistributionRows());
    multStruct.setCost(allNodes.size() +result.getHasDomainNodes().size()+result.getHasRangeNodes().size());
    multStruct.setCount(Query.COUNT-1);

    return multStruct;
  }
      
  public Distribution doMultiply(TwoOpIndexStructure multStruct) {
 
    if (multStruct.getCount() == Query.COUNT){
      return multStruct.getHasResult();
    }
    for (DistributionRow row: multStruct.getHasResult().getHasDistributionRows()) {
      for (int i = 0; i < row.getRow().length; i++) {
        row.getRow()[i] = 0;
      }
    }

    rowMult(0, multStruct.getNodes().getHasNodes(), multStruct.getOp1Rows(), multStruct.getOp2Rows(), multStruct.getResultRows(), 
        multStruct.getOp1ROffset(), multStruct.getOp1RSteps(), multStruct.getOp1COffset(), multStruct.getOp1CSteps(), 
        multStruct.getOp2ROffset(), multStruct.getOp2RSteps(), multStruct.getOp2COffset(), multStruct.getOp2CSteps(), 
        multStruct.getResultROffset(), multStruct.getResultRSteps(), multStruct.getResultCOffset(), multStruct.getResultCSteps() 
    );
    multStruct.setCount(Query.COUNT);
    return multStruct.getHasResult();
  }
  protected void rowMult(int nodeIndex, List<Node> nodes, List<DistributionRow> op1, List<DistributionRow> op2, List<DistributionRow> res, 
      int op1Rindx, int [] op1Rsteps, int op1Cindx, int [] op1Csteps,
      int op2Rindx, int [] op2Rsteps, int op2Cindx, int [] op2Csteps,
      int resRindx, int [] resRsteps, int resCindx, int [] resCsteps
      ) {
    Node n = nodes.get(nodeIndex);
    int limit = (n.getEvidence() == -1) ? n.getDomain().length : 1;
    for (int i = 0; i < limit; i++) {
      if (nodeIndex == nodes.size()-1) {
        res.get(resRindx).getRow()[resCindx] += op1.get(op1Rindx).getRow()[op1Cindx] * op2.get(op2Rindx).getRow()[op2Cindx] ;// do actual mult
      } else {
        rowMult(nodeIndex+1, nodes, op1, op2, res, op1Rindx, op1Rsteps, op1Cindx, op1Csteps,
            op2Rindx, op2Rsteps, op2Cindx, op2Csteps, 
            resRindx, resRsteps, resCindx, resCsteps);
      }
      op1Rindx += op1Rsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      op1Cindx += op1Csteps[nodeIndex]; // % op1Cspan[nodeIndex];
      op2Rindx += op2Rsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      op2Cindx += op2Csteps[nodeIndex]; // % op1Cspan[nodeIndex];
      resRindx += resRsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      resCindx += resCsteps[nodeIndex]; // % op1Cspan[nodeIndex];
    }
  }
  
  public TwoOpIndexStructure makeDivideIndexStructure(Distribution op2, NodeList targetNodes) {
    NodeList allNodes = getHasDomainNodes().union(getHasRangeNodes()).union(op2.getHasDomainNodes()).union(op2.getHasRangeNodes());
    NodeList cNodes = getHasDomainNodes().union(op2.getHasRangeNodes());
    Distribution result = newDistribution(cNodes, getHasRangeNodes().setDifference(cNodes).intersection(targetNodes));
    // make iteration steps for all three sets of rows
    /*
    int thisRowIndex = 0, thisColIndex=0, op2RowIndex = 0, op2ColIndex=0, resultRowIndex = 0, resultColIndex=0;
    int [] thisRowSteps, thisColSteps, op2RowSteps, op2ColSteps, resultRowSteps, resultColSteps;
    thisRowSteps = getHasDomainNodes().makeSteps(allNodes);
    int thisRowOffset = getHasDomainNodes().computeOffset(allNodes);
    thisColSteps = getHasRangeNodes().makeSteps(allNodes);
    int thisColOffset = getHasRangeNodes().computeOffset(allNodes);
    op2RowSteps = op2.getHasDomainNodes().makeSteps(allNodes);
    int op2RowOffset = op2.getHasDomainNodes().computeOffset(allNodes);
    op2ColSteps = op2.getHasRangeNodes().makeSteps(allNodes);
    int op2ColOffset = op2.getHasRangeNodes().computeOffset(allNodes);
    resultRowSteps = result.getHasDomainNodes().makeSteps(allNodes);
    int resultRowOffset = result.getHasDomainNodes().computeOffset(allNodes);
    resultColSteps = result.getHasRangeNodes().makeSteps(allNodes);
    int resultColOffset = result.getHasRangeNodes().computeOffset(allNodes);
     */

    TwoOpIndexStructure multStruct = new TwoOpIndexStructure();
    multStruct.setDist1(this);
    multStruct.setDist2(op2);
    multStruct.setHasResult(result);
    multStruct.setNodeIndex(0);
    multStruct.setNodes(allNodes);
    multStruct.setOp1ROffset(getHasDomainNodes().computeOffset(allNodes));
    multStruct.setOp1RSteps(getHasDomainNodes().makeSteps(allNodes));
    multStruct.setOp1COffset(getHasRangeNodes().computeOffset(allNodes));
    multStruct.setOp1CSteps(getHasRangeNodes().makeSteps(allNodes));
    multStruct.setOp2ROffset(op2.getHasDomainNodes().computeOffset(allNodes));
    multStruct.setOp2RSteps(op2.getHasDomainNodes().makeSteps(allNodes));
    multStruct.setOp2COffset(op2.getHasRangeNodes().computeOffset(allNodes));
    multStruct.setOp2CSteps(op2.getHasRangeNodes().makeSteps(allNodes));
    multStruct.setResultROffset(result.getHasDomainNodes().computeOffset(allNodes));
    multStruct.setResultRSteps(result.getHasDomainNodes().makeSteps(allNodes));
    multStruct.setResultCOffset(result.getHasRangeNodes().computeOffset(allNodes));
    multStruct.setResultCSteps(result.getHasRangeNodes().makeSteps(allNodes));
    multStruct.setOp1Rows(this.getHasDistributionRows());
    multStruct.setOp2Rows(op2.getHasDistributionRows());
    multStruct.setResultRows(result.getHasDistributionRows());
    multStruct.setCost(allNodes.size() +result.getHasDomainNodes().size()+result.getHasRangeNodes().size());
    multStruct.setCount(Query.COUNT-1);
    return multStruct;
  }
      

  public Distribution divide(Distribution op2, NodeList targetNodes) {
    TwoOpIndexStructure divideStructure = makeDivideIndexStructure(op2, targetNodes);
    doDivide(divideStructure);
    return divideStructure.getHasResult();
  }
  
  protected void rowDiv(int nodeIndex, List<Node> nodes, List<DistributionRow> op1, List<DistributionRow> op2, List<DistributionRow> res, 
      int op1Rindx, int [] op1Rsteps, int op1Cindx, int [] op1Csteps,
      int op2Rindx, int [] op2Rsteps, int op2Cindx, int [] op2Csteps,
      int resRindx, int [] resRsteps, int resCindx, int [] resCsteps
      ) {
    Node n = nodes.get(nodeIndex);
    for (int i = 0; i < n.getDomain().length; i++) {
      if (nodeIndex == nodes.size()-1) {
        res.get(resRindx).getRow()[resCindx] += op1.get(op1Rindx).getRow()[op1Cindx] / op2.get(op2Rindx).getRow()[op2Cindx] ;// do actual mult
      } else {
        rowDiv(nodeIndex+1, nodes, op1, op2, res, op1Rindx, op1Rsteps, op1Cindx, op1Csteps,
            op2Rindx, op2Rsteps, op2Cindx, op2Csteps, 
            resRindx, resRsteps, resCindx, resCsteps);
      }
      op1Rindx += op1Rsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      op1Cindx += op1Csteps[nodeIndex]; // % op1Cspan[nodeIndex];
      op2Rindx += op2Rsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      op2Cindx += op2Csteps[nodeIndex]; // % op1Cspan[nodeIndex];
      resRindx += resRsteps[nodeIndex]; // % op1Rspan[nodeIndex]; (shouldn't actually be needed, right?)
      resCindx += resCsteps[nodeIndex]; // % op1Cspan[nodeIndex];
    }
  }
  
  public Distribution doDivide(TwoOpIndexStructure multStruct) {

    if (multStruct.getCount() == Query.COUNT){
      return multStruct.getHasResult();
    }

    for (DistributionRow row: multStruct.getHasResult().getHasDistributionRows()) {
      for (int i = 0; i < row.getRow().length; i++) {
        row.getRow()[i] = 0;
      }
    }

    rowDiv(0, multStruct.getNodes().getHasNodes(), multStruct.getOp1Rows(), multStruct.getOp2Rows(), multStruct.getResultRows(), 
        multStruct.getOp1ROffset(), multStruct.getOp1RSteps(), multStruct.getOp1COffset(), multStruct.getOp1CSteps(), 
        multStruct.getOp2ROffset(), multStruct.getOp2RSteps(), multStruct.getOp2COffset(), multStruct.getOp2CSteps(), 
        multStruct.getResultROffset(), multStruct.getResultRSteps(), multStruct.getResultCOffset(), multStruct.getResultCSteps() 
    );
    multStruct.setCount(Query.COUNT);
    return multStruct.getHasResult();
  }

  /** 
   * 
   * @param srm - relevant the graph 
   * @param range - a list of target nodes
   * @param domain - a list of conditioning nodes
   * @return - a new distribution, with no rows
   * 
   * does not invalidate queries
   */
  public static Distribution makeConditionalDistribution(GraphTMP srm, NodeList domain, NodeList range) {
    // build node marginal distribution
    Distribution d = new Distribution();
    d.setHasDomainNodes(domain);
    d.setHasRangeNodes(range);
    d.setHasDistributionRows(new ArrayList<DistributionRow>());
    srm.addDistribution(d);
    for (int n = 0; n < range.size(); n++) {
      Node node = range.get(n);
      node.add1HasDistributions(d);
    }
    return d;
  }
  
  /**
   * @param conditioningCase - an indexVector to search for
   * @return - the distribution row matching the case, or null
   * 
   */

  public DistributionRow getRow(int [] conditioningCase) {
    for (DistributionRow row: getHasDistributionRows()) {
      if (row.caseMatch(conditioningCase)) {
        return row;
      }
    }
    return null;
  }
  
  
  public boolean normalize() {
    for (DistributionRow row: getHasDistributionRows()) {
      row.normalize();
    }
    return true;
  }
  
  public Distribution convertConditionalToLikelihood () {
    // now build an empty ONE distribution so we can convert above into conditional to make it easy to find case.
    // this works because divide doesnt normalize, but notice we will get 1/posterior for case!
    Distribution denom = multiply(Distribution.ONE(), getHasRangeNodes());
    for (DistributionRow row: denom.getHasDistributionRows()) {
      for (int i = 0; i < row.row.length; i++ ) {
        row.row[i] = 1.0;
      }
    }
    Distribution result = divide(denom, getAllNodes());
    return result;
  }
  
  public Distribution computeConditional (NodeList newDomain, NodeList newRange) {
    // now build an empty ONE distribution so we can convert above into conditional to make it easy to find case.
    // this works because divide doesnt normalize, but notice we will get 1/posterior for case!
    Distribution denom = multiply(Distribution.ONE(), newDomain);
    denom.normalize();
    Distribution result = divide(denom, getAllNodes());
    return result;
  }
  
  public long export(BufferedWriter writer, JSONObject json, HashMap <Object, Long> objectIndex) 
      throws IOException, JSONException {
    if (objectIndex.containsKey(this)) {
      return objectIndex.get(this);
    } else {
      long distId = GraphTMP.nextJSONId();
      objectIndex.put(this, distId);
      JSONObject distJSON = asJSON();
      JSONArray jsonDistributionRows = new JSONArray();
      if (getHasDistributionRows() != null) {
        for (DistributionRow row: getHasDistributionRows()) {
          jsonDistributionRows.put(row.export(writer, json, objectIndex));
        }
        distJSON.put("hasDistributionRows", jsonDistributionRows);
      }
      JSONArray jsonDomainNodes = new JSONArray();
      if (getHasDomainNodes() != null) {
        for (int n = 0; n < getHasDomainNodes().size(); n++) {
          Node node =  getHasDomainNodes().get(n);
          jsonDomainNodes.put(node.export(writer, json, objectIndex));
        }
        distJSON.put("hasDomainNodes", jsonDomainNodes);
      }
      JSONArray jsonRangeNodes = new JSONArray();
      if (getHasRangeNodes() != null) {
        for (int n = 0; n < getHasRangeNodes().size(); n++) {
          Node node =  getHasRangeNodes().get(n);
          jsonRangeNodes.put(node.export(writer, json, objectIndex));
        }
        distJSON.put("hasRangeNodes", jsonRangeNodes);
      }
      json.put(""+distId, distJSON);
      return distId;
    }
  }

}
