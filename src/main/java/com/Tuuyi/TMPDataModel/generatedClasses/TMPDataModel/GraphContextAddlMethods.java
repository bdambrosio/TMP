/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
//import
import com.Tuuyi.TMPDataModel.PropagationFilter;

public class GraphContextAddlMethods extends GraphContext {

//DL public GraphContext(InstanceSparseGraph graph, double aScatterThreshold) {
//DL  setHasModel(graph);
//DL  clear();
//DL  setScatterThreshold(aScatterThreshold);
//DL }
  
//DL public GraphContext(Projection projection, double aScatterThreshold) {
//DL  setHasModel(projection);
//DL  clear();
//DL  setScatterThreshold(aScatterThreshold);
//DL }
  
//DL public GraphContext(InstanceSparseGraph graph) {
//DL  setHasModel(graph);
//DL  clear();
//DL  setScatterThreshold(1.0);
//DL }
  
//DL public GraphContext(Projection projection) {
//DL  setHasModel(projection);
//DL  clear();
//DL  setScatterThreshold(1.0);
//DL }
  
  PropagationFilter propagationFilter = null;
  
  /** todo - note this is NOT threadsafe! **/
  private HashMap<WeightedSubjectArc, Integer> propagated = new HashMap<WeightedSubjectArc,Integer> ();
  
  /** assumes graph has been set **/
  public void clear() {
    setInputNamespace(hasModel.getInputNamespace());
    Beliefspace inputBeliefspace = new Beliefspace();
    inputBeliefspace.setNamespace(hasModel.getInputNamespace());
    setInputBeliefspace(inputBeliefspace);
    Beliefspace outputBeliefspace = new Beliefspace();
    outputBeliefspace.setNamespace(hasModel.getOutputNamespace());
    setOutputBeliefspace(outputBeliefspace);
    setOutputNamespace(hasModel.getOutputNamespace());
    setHasSource(Collector.newCollector());
    hasSource.setContext(this);
    hasSource.setNamespace(inputNamespace);
    hasSource.setBeliefspace(inputBeliefspace);
    setHasSink(Collector.newCollector());
    hasSink.setContext(this);
    hasSink.setNamespace(outputNamespace);
    hasSink.setBeliefspace(outputBeliefspace);
    setHasMapMethod(hasModel.newMapper(getHasSource(), getHasSink()));
    hasMapMethod.setContext(this);
    setHasDefaultInputChannel(new Channel(this, 1.0));
    propagated.clear();
  }
  
  public void setPropagationFilter(PropagationFilter p) {
    propagationFilter = p;
  }

  public PropagationFilter getPropagationFilter() {
    return propagationFilter;
  }
  
  public void send(MapReduceItem item, double delta) {
    if (((InstanceSparseGraphMapper)this.getHasMapMethod()).direction == InstanceSparseGraphMapper.FORWARD_MAP) {
      getHasDefaultInputChannel().send(item, delta);
    } else {
      this.hasSink.collect(((InstanceSparseGraphMapper)getHasMapMethod()).getAsOutput(item.item), delta);
    }
  }
  
  
  public MapReduceItem getAsInput(String item) {
    return this.hasMapMethod.getAsInput(item);
  }


  public MapReduceItem getAsOutput(String item) {
    return this.hasMapMethod.getAsOutput(item);
  }


  public void send(ArrayList<MapReduceItem> items) {
    for (MapReduceItem item: items) {
      send(item.getItem(), item.getScore());
    }
  }

  public void send(String item, double delta) {
    if (((InstanceSparseGraphMapper)this.getHasMapMethod()).direction == InstanceSparseGraphMapper.FORWARD_MAP) {
      getHasDefaultInputChannel().send(item, delta);
    } else {
      this.hasSink.collect(((InstanceSparseGraphMapper)getHasMapMethod()).getAsOutput(item), delta);
    }
  }

  public void send(String item) {
    send(item, 1.0);
  }

  public void send(String [] items) {
    for (String item: items) {
      send(item, 1.0);
    }
  }

  public void scatter() {
    getHasMapMethod().scatter(scatterThreshold);
  }
  
  public void scatter(boolean fillin) {
    getHasMapMethod().scatter(scatterThreshold, fillin);
  }
  
  public void scatter(boolean fillin, int targetItemCount, long timeLimitMs) {
    getHasMapMethod().scatter(scatterThreshold, fillin, targetItemCount, timeLimitMs);
  }
  
  public void biScatter(ArrayList<MapReduceItem> seed, double scatterThreshold, int targetCnt, boolean fillin) {
    getHasMapMethod().scatter(scatterThreshold, fillin);
    ArrayList<MapReduceItem> backscatter = gather();
    if (backscatter.size() > targetCnt) {
      hasSink.addAll(backscatter);
      return;
    }
    backscatter.addAll(seed);
    for (MapReduceInProcessItem mripi: ((InstanceSparseGraphMapper)getHasMapMethod()).nextSweepQueue) {
      backscatter.add(mripi.getHasMapReduceItem());
    }
    ArrayList<MapReduceItem>normalizedBackscatter = normalize(backscatter);
    ((InstanceSparseGraphMapper)getHasMapMethod()).switchDirection();
    send(normalizedBackscatter);
    getHasMapMethod().scatter(1.0, fillin); // low threshold on backscatter to ensure we have items to propagate
    backscatter = gather();
    normalizedBackscatter = normalize(backscatter);
    ((InstanceSparseGraphMapper)getHasMapMethod()).switchDirection();
    send(normalizedBackscatter);
    getHasMapMethod().scatter(scatterThreshold, fillin);
  }
  
  /** assumes seed has been set on appropriate collector and initial direction has been set **/
  /** usual use case is initial direction is reverse and seed is in outputCollector         **/
  public void backScatter(double forwardThreshold, boolean fillin) {
    getHasMapMethod().scatter(1, true);
    ArrayList<MapReduceItem> backscatter = gather();
    ArrayList<MapReduceItem>normalizedBackscatter = normalize(backscatter);
    ((InstanceSparseGraphMapper)getHasMapMethod()).switchDirection();
    send(normalizedBackscatter);
    getHasMapMethod().scatter(forwardThreshold, fillin);  }
  
  public void backScatter(boolean fill) {
    getHasMapMethod().scatter(1, fill);
    ArrayList<MapReduceItem> results = gather();
    ((InstanceSparseGraphMapper)getHasMapMethod()).switchDirection();
    send(results);
    getHasMapMethod().scatter(scatterThreshold, fill); 
  }
  
  public ArrayList<MapReduceItem> gather () {
    boolean forward = ((InstanceSparseGraphMapper)this.getHasMapMethod()).direction == InstanceSparseGraphMapper.FORWARD_MAP;
    Collector from = getHasSink();
    if (!forward) {
      from = getHasSource();
    }
   ArrayList<MapReduceItem> result = new ArrayList<MapReduceItem> ();
    MapReduceInProcessItem next = null;
    while (from.hasMore() && (next = from.nextItem()) != null) {
      MapReduceItem item = next.getHasMapReduceItem();
      MapReduceItem mri = (forward ? getHasMapMethod().getAsOutput(item.getItem()) : getHasMapMethod().getAsInput(item.getItem()));
      result.add(mri);
    }
    return result;
  }

  public ArrayList<MapReduceItem> gather (boolean merge) {
    ArrayList<MapReduceItem> result = new ArrayList<MapReduceItem> ();
    boolean forward = ((InstanceSparseGraphMapper)this.getHasMapMethod()).direction == InstanceSparseGraphMapper.FORWARD_MAP;
    Collector from = getHasSink();
    if (!forward) {
      from = getHasSource();
    }
    MapReduceInProcessItem next = null;
    while (from.hasMore() && (next = from.nextItem()) != null) {
      MapReduceItem item = next.getHasMapReduceItem();
      MapReduceItem mri = (forward ? getHasMapMethod().getAsOutput(item.getItem()) : getHasMapMethod().getAsInput(item.getItem()));
      /** hack - new scatter doesn't post delta till after scatter, so we need to do it here. **/
      if (merge) {
        item.setScore(next.getHasDelta()+mri.getScore()-next.getHasDelta()*mri.getScore());
      }
      result.add(item);
    }
    return result;
  }

  ArrayList<MapReduceItem> normalize(ArrayList<MapReduceItem> mris) {
    ArrayList<MapReduceItem> normalized = new ArrayList<MapReduceItem>(mris.size());
    double max = 0.0;
    for (MapReduceItem mri: mris) {
      if (mri.score > max) {
        max = mri.score;
      }
    }
    if (max <= 0.0) {
      return mris;
    }
    for (MapReduceItem mri: mris) {
      normalized.add(new MapReduceItem(mri.item, mri.score/max));
    }
    return normalized;
  }
}
