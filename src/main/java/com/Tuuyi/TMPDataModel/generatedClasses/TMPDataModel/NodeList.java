/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.HashSet;

public class NodeList extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(NodeList.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  private ArrayList<Node> hasNodes = new ArrayList<Node>();

  /** if no arg, assume from db **/
  public NodeList() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public NodeList(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
    hasNodes= new ArrayList<Node>(0);
  }
  public NodeList(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
    hasNodes= new ArrayList<Node>(0);
  }
  public List<Node> getHasNodes() {
      return hasNodes;
  }
  public int getId() {
    return id;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasNodes(Collection<Node> newHasNodes) {
    hasNodes=new ArrayList<Node>(newHasNodes);
  }

  public void add1HasNodes(Node newHasNodes) {
    hasNodes.add(newHasNodes);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasNodes(Collection<Node> newHasNodes) {
    hasNodes.addAll(newHasNodes);
  }

  public boolean remove1HasNodes(Node newHasNodes) {
    return hasNodes.remove(newHasNodes);
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
        NodeListManager.getInstance().putInCache(this);
      }
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "NodeList");
      jsonObj.put("id", id);
      if (getHasNodes() != null) {
        JSONArray jsonHasNodes = new JSONArray();
        for (Node row: getHasNodes()) {
          jsonHasNodes.put(row.getId());
        }
        jsonObj.put("hasNodes", jsonHasNodes);
      }
      jsonObj.put("id", getId());
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "NodeList");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getHasNodes() != null) {
        JSONArray jsonHasNodes = new JSONArray();
        for (Node row: getHasNodes()) {
          jsonHasNodes.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasNodes", jsonHasNodes);
      }
      jsonObj.put("id", getId());
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray hasNodesArray = jsonObj.optJSONArray("hasNodes");
      if(hasNodesArray != null) {
        ArrayList<Node> aListOfHasNodes = new ArrayList<Node>(hasNodesArray.length());
        for (int i = 0; i < hasNodesArray.length(); i++) {
          int id = hasNodesArray.optInt(i);
          if (NodeManager.getInstance().get(id) != null) {
            aListOfHasNodes.add(NodeManager.getInstance().get(id));
          }
        }
        setHasNodes(aListOfHasNodes);
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  public NodeList(NodeList old) {
    hasNodes = new ArrayList<Node>(old.hasNodes);
  }
  
  public NodeList(Node [] nodes) {
    for (Node n: nodes) {
      addNode(n);
    }
  }
  
  public NodeList(ArrayList<Node>nodes) {
    hasNodes = nodes;
  }
  
  public NodeList(Node node) {
    hasNodes.add(node);
  }
  
  public Node get(int index) {
    return getHasNodes().get(index);
  }
  
  public boolean member(Node target) {
    return getHasNodes().contains(target);
  }
  
  public NodeList addNode(Node n) {
    ArrayList <Node> nodes = new ArrayList<Node>(getHasNodes());
    // search for insertion location
    int index = 0;
    int size = nodes.size();
    while (index < size && nodes.get(index).getOrder() < n.getOrder()) {
      index++;
    }
    // test if already in list
    if (index < size && nodes.get(index).getOrder() == n.getOrder()) {
      return this;
    } else if (index == size) {
      // add to end if last element
      nodes.add(n);
      this.setHasNodes(nodes);
      return this;
    } else { // copy tail to make room
      int lastIndex = nodes.size()-1;
      nodes.add(nodes.get(lastIndex));
      for (int copyIndex = lastIndex; copyIndex > index; copyIndex--) {
        nodes.set(copyIndex, nodes.get(copyIndex-1));
      }
      nodes.set(index, n);
      }
    this.setHasNodes(nodes);
    return this;
  }

  /**
   * note - destructive, modifies in place
   */
  public NodeList removeNode(Node n) {
    getHasNodes().remove(n);
    return this;
  }

 protected static HashSet<Node> unionSet = new HashSet<Node>();  
  public synchronized NodeList union(NodeList op2) {
    unionSet.clear();
    for (int i = 0; i < this.size(); i++) {
      unionSet.add(this.get(i));
    }
    NodeList result = new NodeList(this);
    for (Node n: op2.getHasNodes()) {
      if (!unionSet.contains(n)) {
        result.addNode(n);
      }
    }
    return result;
  }

  public NodeList intersection(NodeList op2) {
    return this.union(op2).setDifference(this.setDifference(op2).union(op2.setDifference(this)));
  }

  
  public NodeList setDifference(NodeList op2) {
    NodeList result =  new NodeList(this);
    for (Node n: op2.getHasNodes()) {
      result.remove1HasNodes(n);
    }
    return result;
  }

  public boolean intersects (NodeList op2) {
    for (Node n: hasNodes) {
      if (op2.hasNodes.contains(n)) {
        return true;  
      }
    }
    return false;
  }
  
  public int size() {
    return getHasNodes().size();
  }
  
  public int distributionSize() {
    int dSize = 1;
    for (Node n: getHasNodes()) {
      dSize *= n.getDomain().length;
    }
    return dSize;
  }
  
  public int [] makeSteps (NodeList targets) {
    int [] steps = new int [targets.size()];
    int step = 1;
    for (int nIndx = targets.size()-1; nIndx >= 0; nIndx--) {
      Node target = targets.get(nIndx);
      if (target.getEvidence() == -1 && member(target)) {
        steps[nIndx] = step;
      } else {
        steps[nIndx] = 0;
      }
      if (member(target)) {
        step *= target.getDomain().length;
      }
    }
    return steps;
  }
    
  public int  computeOffset (NodeList targets) {
    int  offset = 0;
    int step = 1;
    int index = 1;
    for (int nIndx = targets.size()-1; nIndx >= 0; nIndx--) {
      Node target = targets.get(nIndx);
      if (member(target)) {
        if (target.getEvidence() == -1) {
          offset += 0;
        } else {
          offset+= step * target.getEvidence();
        }
        step *= target.getDomain().length;
      }
    }
    return offset;
  }
  
 static HashMap <NodeList, int [][]> rowCaseCache = new HashMap <NodeList, int [][]>();
  // nice try, but slower than just making new every time.
  protected int [][] getRowCases () {
    int [][] rowCases = rowCaseCache.get(this);
    if (rowCases == null) {
      rowCases = makeRowCases();
      rowCaseCache.put(this, rowCases);
    }
    return rowCases;
  }
  
   public int [][] makeRowCases() {
    int [][] cases = new int [distributionSize()][size()];
    for (int i = 0; i < distributionSize(); i++) {
      cases [i] = new int [size()];
    }
    int span = distributionSize();
    for (int i = 0; i < size(); i++) {
      span /= getHasNodes().get(i).getDomain().length; //first var is most slowly varying
      initializeRowCases(cases, i, span);
    }
    return cases;
  }

  protected void initializeRowCases(int [] [] cases, int nodeIndex, int span) {
    String [] domain = getHasNodes().get(nodeIndex).getDomain();
    int domainSize = domain.length;
    int subscript = 0;
    for (int caseIndex = 0; caseIndex < cases.length; caseIndex++) {
      if (caseIndex != 0 && caseIndex % span == 0) {
        subscript = (subscript+1) % domainSize;
      }
      cases [caseIndex] [nodeIndex] = subscript;
    }
  }
  
  /** 
   * @param n2 - the list to compare
   * @return a boolean - true if the two lists contain identical nodes
   * takes advantage of the fact that NodeList maintains an ordered set of nodes
   */
  public boolean matches (NodeList n2) {
    if (this == null || n2 == null) {
      return false;
    }
    if (this.size() != n2.size()) {
      return false;
    }
    for (int i = 0; i < this.hasNodes.size(); i++) {
      if (this.hasNodes.get(i) != n2.hasNodes.get(i)) {
        return false;
      }
    }
    return true;
  }
  
  public String toString() {
    StringBuffer buf = new StringBuffer();
    buf.append("[");
    for (Node node: hasNodes) {
      buf.append(node.toString());
      buf.append(",");
    }
    return buf.toString();
  }

  public boolean equals(Object o) {
    if (!(o instanceof NodeList ) ) {
    return false;
    }
    NodeList other = (NodeList) o;
    if (this == other) {
      return true;
    } else {
      if (size() == other.size()) {
        for (int i = 0; i < size(); i++) {
          if (hasNodes.get(i) != other.hasNodes.get(i)) {
            return false;
          }
        }
        return true;
      }
    return false;
    }
  }

  public int hashCode() {
    int code = 0;
    int index = 0;
    for (Node n: hasNodes) {
      code += index*n.getOrder();
      index *= 4;
    }
    return code;
  }
}
