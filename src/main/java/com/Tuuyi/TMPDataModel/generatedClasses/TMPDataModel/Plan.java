/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class Plan extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(Plan.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  boolean changed;
  private ArrayList<Distribution> hasResults = new ArrayList<Distribution>();
  double cost;
  protected ArrayList<Plan> children = new ArrayList<Plan>(0);

  public void setChildrenRawValueInternal(String rawVal) {
  }

  protected ArrayList<TwoOpIndexStructure> operations = new ArrayList<TwoOpIndexStructure>(0);

  public void setOperationsRawValueInternal(String rawVal) {
  }


  /** if no arg, assume from db **/
  public Plan() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public Plan(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
    hasResults= new ArrayList<Distribution>(0);
  }
  public Plan(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
    hasResults= new ArrayList<Distribution>(0);
  }
  public boolean getChanged() {
    return changed;
  }
  public List<Distribution> getHasResults() {
      return hasResults;
  }
  public int getId() {
    return id;
  }
  public double getCost() {
    return cost;
  }
  public boolean childrenAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsChildren(Plan value) {
      return children.contains(value);
  }

  public ArrayList<Plan> getChildren() {
      return children;
  }
  public boolean operationsAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsOperations(TwoOpIndexStructure value) {
      return operations.contains(value);
  }

  public ArrayList<TwoOpIndexStructure> getOperations() {
      return operations;
  }
  public void setChanged (boolean a_changed) {
    changed = a_changed;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasResults(Collection<Distribution> newHasResults) {
    hasResults=new ArrayList<Distribution>(newHasResults);
  }

  public void add1HasResults(Distribution newHasResults) {
    hasResults.add(newHasResults);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasResults(Collection<Distribution> newHasResults) {
    hasResults.addAll(newHasResults);
  }

  public boolean remove1HasResults(Distribution newHasResults) {
    return hasResults.remove(newHasResults);
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }
  public void setCost (double a_cost) {
    cost = a_cost;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setChildren(Collection<Plan> newChildren) {
    children=new ArrayList<Plan>(newChildren);
  }

  public void add1Children(Plan newChildren) {
    children.add(newChildren);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllChildren(Collection<Plan> newChildren) {
    children.addAll(newChildren);
  }

  public boolean remove1Children(Plan newChildren) {
    return children.remove(newChildren);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setOperations(Collection<TwoOpIndexStructure> newOperations) {
    operations=new ArrayList<TwoOpIndexStructure>(newOperations);
  }

  public void add1Operations(TwoOpIndexStructure newOperations) {
    operations.add(newOperations);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllOperations(Collection<TwoOpIndexStructure> newOperations) {
    operations.addAll(newOperations);
  }

  public boolean remove1Operations(TwoOpIndexStructure newOperations) {
    return operations.remove(newOperations);
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof Plan)) //covers o == null case
      return false;
    Plan other = (Plan)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Plan");
      jsonObj.put("id", id);
      jsonObj.put("changed", getChanged());
      if (getHasResults() != null) {
        JSONArray jsonHasResults = new JSONArray();
        for (Distribution row: getHasResults()) {
          jsonHasResults.put(row.getId());
        }
        jsonObj.put("hasResults", jsonHasResults);
      }
      jsonObj.put("id", getId());
      jsonObj.put("cost", getCost());
       if (getChildren() != null) {
         String ChildrenAsString = "";
         for (Plan Childrenitem: getChildren()) {
           ChildrenAsString += Childrenitem.getId() + ",";
           ChildrenAsString.replaceFirst(",$", "");
         }
         jsonObj.put("children", ChildrenAsString);
       }
       if (getOperations() != null) {
         String OperationsAsString = "";
         for (TwoOpIndexStructure Operationsitem: getOperations()) {
           OperationsAsString += Operationsitem.getId() + ",";
           OperationsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("operations", OperationsAsString);
       }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Plan");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("changed", getChanged());
      if (getHasResults() != null) {
        JSONArray jsonHasResults = new JSONArray();
        for (Distribution row: getHasResults()) {
          jsonHasResults.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasResults", jsonHasResults);
      }
      jsonObj.put("id", getId());
      jsonObj.put("cost", getCost());
       if (getChildren() != null) {
         String ChildrenAsString = "";
         for (Plan Childrenitem: getChildren()) {
           ChildrenAsString += Childrenitem.getId() + ",";
           ChildrenAsString.replaceFirst(",$", "");
         }
         jsonObj.put("children", ChildrenAsString);
       }
       if (getOperations() != null) {
         String OperationsAsString = "";
         for (TwoOpIndexStructure Operationsitem: getOperations()) {
           OperationsAsString += Operationsitem.getId() + ",";
           OperationsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("operations", OperationsAsString);
       }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("changed")) {
        setChanged(jsonObj.optBoolean("changed"));
      }
      JSONArray hasResultsArray = jsonObj.optJSONArray("hasResults");
      if(hasResultsArray != null) {
        ArrayList<Distribution> aListOfHasResults = new ArrayList<Distribution>(hasResultsArray.length());
        for (int i = 0; i < hasResultsArray.length(); i++) {
          int id = hasResultsArray.optInt(i);
          if (DistributionManager.getInstance().get(id) != null) {
            aListOfHasResults.add(DistributionManager.getInstance().get(id));
          }
        }
        setHasResults(aListOfHasResults);
      }
      if (!jsonObj.isNull("cost")) {
        setCost(jsonObj.optDouble("cost"));
      }
      if (!jsonObj.isNull("children")) {
      String [] childrenAsStrings = jsonObj.optString("children").split(",");
      ArrayList<Plan> childrenValues = new ArrayList<Plan>(childrenAsStrings.length);
      for (String childrenItemId: childrenAsStrings) {
      if (childrenItemId != null && PlanManager.getInstance().get(Integer.parseInt(childrenItemId)) != null) {
          childrenValues.add(PlanManager.getInstance().get(Integer.parseInt(childrenItemId)));
        }
      }
      children = childrenValues;
      }
      if (!jsonObj.isNull("operations")) {
      String [] operationsAsStrings = jsonObj.optString("operations").split(",");
      ArrayList<TwoOpIndexStructure> operationsValues = new ArrayList<TwoOpIndexStructure>(operationsAsStrings.length);
      for (String operationsItemId: operationsAsStrings) {
      if (operationsItemId != null && TwoOpIndexStructureManager.getInstance().get(Integer.parseInt(operationsItemId)) != null) {
          operationsValues.add(TwoOpIndexStructureManager.getInstance().get(Integer.parseInt(operationsItemId)));
        }
      }
      operations = operationsValues;
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  public Plan(Plan plan) {
    boolean changed;
    this.hasResults = plan.hasResults;
    this.children = new ArrayList<Plan>(0);
    this.cost = plan.cost;
    this.operations = plan.operations;
  }
}
