/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class ItemProjection extends  Item {

  protected static final Logger logWriter = Logger.getLogger(ItemProjection.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  protected ArrayList<ScoredTerm> hasOntologyTerms = new ArrayList<ScoredTerm>(0);

  public void setHasOntologyTermsRawValueInternal(String rawVal) {
  }


  /** if no arg, assume from db **/
  public ItemProjection() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public ItemProjection(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public ItemProjection(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public int getId() {
    return id;
  }
  public boolean hasOntologyTermsAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsHasOntologyTerms(ScoredTerm value) {
      return hasOntologyTerms.contains(value);
  }

  public ArrayList<ScoredTerm> getHasOntologyTerms() {
      return hasOntologyTerms;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasOntologyTerms(Collection<ScoredTerm> newHasOntologyTerms) {
    hasOntologyTerms=new ArrayList<ScoredTerm>(newHasOntologyTerms);
  }

  public void add1HasOntologyTerms(ScoredTerm newHasOntologyTerms) {
    hasOntologyTerms.add(newHasOntologyTerms);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasOntologyTerms(Collection<ScoredTerm> newHasOntologyTerms) {
    hasOntologyTerms.addAll(newHasOntologyTerms);
  }

  public boolean remove1HasOntologyTerms(ScoredTerm newHasOntologyTerms) {
    return hasOntologyTerms.remove(newHasOntologyTerms);
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof ItemProjection)) //covers o == null case
      return false;
    ItemProjection other = (ItemProjection)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "ItemProjection");
      jsonObj.put("id", id);
      jsonObj.put("id", getId());
       if (getHasOntologyTerms() != null) {
         String HasOntologyTermsAsString = "";
         for (ScoredTerm HasOntologyTermsitem: getHasOntologyTerms()) {
           HasOntologyTermsAsString += HasOntologyTermsitem.getId() + ",";
           HasOntologyTermsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasOntologyTerms", HasOntologyTermsAsString);
       }
      if (getHasAbstraction() != null) {
        jsonObj.put("hasAbstraction", getHasAbstraction().getId());
      }
      jsonObj.put("id", getId());
      jsonObj.put("score", getScore());
      jsonObj.put("itemId", getItemId());
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "ItemProjection");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("id", getId());
       if (getHasOntologyTerms() != null) {
         String HasOntologyTermsAsString = "";
         for (ScoredTerm HasOntologyTermsitem: getHasOntologyTerms()) {
           HasOntologyTermsAsString += HasOntologyTermsitem.getId() + ",";
           HasOntologyTermsAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasOntologyTerms", HasOntologyTermsAsString);
       }
      if (getHasAbstraction() != null) {
        jsonObj.put("hasAbstraction", getHasAbstraction().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      jsonObj.put("score", getScore());
      jsonObj.put("itemId", getItemId());
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("hasOntologyTerms")) {
      String [] hasOntologyTermsAsStrings = jsonObj.optString("hasOntologyTerms").split(",");
      ArrayList<ScoredTerm> hasOntologyTermsValues = new ArrayList<ScoredTerm>(hasOntologyTermsAsStrings.length);
      for (String hasOntologyTermsItemId: hasOntologyTermsAsStrings) {
      if (hasOntologyTermsItemId != null && ScoredTermManager.getInstance().get(Integer.parseInt(hasOntologyTermsItemId)) != null) {
          hasOntologyTermsValues.add(ScoredTermManager.getInstance().get(Integer.parseInt(hasOntologyTermsItemId)));
        }
      }
      hasOntologyTerms = hasOntologyTermsValues;
      }
      if (!jsonObj.isNull("hasAbstraction")) {
        int hasAbstractionId = jsonObj.optInt("hasAbstraction");
        Abstraction value = AbstractionManager.getInstance().get(hasAbstractionId);
        if(value != null) {
            setHasAbstraction(value);
        }
      }
      if (!jsonObj.isNull("score")) {
        setScore(jsonObj.optDouble("score"));
      }
      if (!jsonObj.isNull("itemId")) {
        setItemId(jsonObj.optString("itemId"));
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


    public ItemProjection(AbstractItem ai, Collection<ScoredTerm> terms) {
      this.setItemId(ai.getItemId());
      this.setHasOntologyTerms(terms);
    }

}
