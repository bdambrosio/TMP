/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class TwoOpIndexStructure extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(TwoOpIndexStructure.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  private ArrayList<DistributionRow> op2Rows = new ArrayList<DistributionRow>();
  int resultCOffset;
  private ArrayList<DistributionRow> resultRows = new ArrayList<DistributionRow>();
  int [] op1CSteps;
  int op1COffset;
  int [] op2CSteps;
  int op1ROffset;
  int [] op2RSteps;
  int resultROffset;
  int [] resultCSteps;
  private ArrayList<DistributionRow> op1Rows = new ArrayList<DistributionRow>();
  int op2COffset;
  protected Distribution dist1 = null;

  int op2ROffset;
  double count;
  protected Distribution HasResult = null;

  double cost;
  int nodeIndex;
  protected Distribution dist2 = null;

  protected NodeList nodes = null;

  int [] resultRSteps;
  int [] op1RSteps;

  /** if no arg, assume from db **/
  public TwoOpIndexStructure() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public TwoOpIndexStructure(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
    op2Rows= new ArrayList<DistributionRow>(0);
    resultRows= new ArrayList<DistributionRow>(0);
    op1Rows= new ArrayList<DistributionRow>(0);
  }
  public TwoOpIndexStructure(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
    op2Rows= new ArrayList<DistributionRow>(0);
    resultRows= new ArrayList<DistributionRow>(0);
    op1Rows= new ArrayList<DistributionRow>(0);
  }
  public List<DistributionRow> getOp2Rows() {
      return op2Rows;
  }
  public int getResultCOffset() {
    return resultCOffset;
  }
  public List<DistributionRow> getResultRows() {
      return resultRows;
  }
  public int [] getOp1CSteps() {
    return op1CSteps;
  }
  public int getOp1COffset() {
    return op1COffset;
  }
  public int [] getOp2CSteps() {
    return op2CSteps;
  }
  public int getOp1ROffset() {
    return op1ROffset;
  }
  public int [] getOp2RSteps() {
    return op2RSteps;
  }
  public int getResultROffset() {
    return resultROffset;
  }
  public int [] getResultCSteps() {
    return resultCSteps;
  }
  public List<DistributionRow> getOp1Rows() {
      return op1Rows;
  }
  public int getOp2COffset() {
    return op2COffset;
  }
  public boolean Dist1IsResident() {
      return true;
  }
  public Distribution getDist1() {

    return dist1;
  }
  public int getDist1InternalId() {
    if (dist1 == null) {
      return -1;
    } else { 
      return dist1.getId();
    }
  }
  public int getOp2ROffset() {
    return op2ROffset;
  }
  public int getId() {
    return id;
  }
  public double getCount() {
    return count;
  }
  public boolean HasResultIsResident() {
      return true;
  }
  public Distribution getHasResult() {

    return HasResult;
  }
  public int getHasResultInternalId() {
    if (HasResult == null) {
      return -1;
    } else { 
      return HasResult.getId();
    }
  }
  public double getCost() {
    return cost;
  }
  public int getNodeIndex() {
    return nodeIndex;
  }
  public boolean Dist2IsResident() {
      return true;
  }
  public Distribution getDist2() {

    return dist2;
  }
  public int getDist2InternalId() {
    if (dist2 == null) {
      return -1;
    } else { 
      return dist2.getId();
    }
  }
  public boolean NodesIsResident() {
      return true;
  }
  public NodeList getNodes() {

    return nodes;
  }
  public int getNodesInternalId() {
    if (nodes == null) {
      return -1;
    } else { 
      return nodes.getId();
    }
  }
  public int [] getResultRSteps() {
    return resultRSteps;
  }
  public int [] getOp1RSteps() {
    return op1RSteps;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setOp2Rows(Collection<DistributionRow> newOp2Rows) {
    op2Rows=new ArrayList<DistributionRow>(newOp2Rows);
  }

  public void add1Op2Rows(DistributionRow newOp2Rows) {
    op2Rows.add(newOp2Rows);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllOp2Rows(Collection<DistributionRow> newOp2Rows) {
    op2Rows.addAll(newOp2Rows);
  }

  public boolean remove1Op2Rows(DistributionRow newOp2Rows) {
    return op2Rows.remove(newOp2Rows);
  }
  public void setResultCOffset (int a_resultCOffset) {
    resultCOffset = a_resultCOffset;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setResultRows(Collection<DistributionRow> newResultRows) {
    resultRows=new ArrayList<DistributionRow>(newResultRows);
  }

  public void add1ResultRows(DistributionRow newResultRows) {
    resultRows.add(newResultRows);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllResultRows(Collection<DistributionRow> newResultRows) {
    resultRows.addAll(newResultRows);
  }

  public boolean remove1ResultRows(DistributionRow newResultRows) {
    return resultRows.remove(newResultRows);
  }
  public void setOp1CSteps (int [] a_op1CSteps) {
    op1CSteps = a_op1CSteps;
  }
  public void setOp1COffset (int a_op1COffset) {
    op1COffset = a_op1COffset;
  }
  public void setOp2CSteps (int [] a_op2CSteps) {
    op2CSteps = a_op2CSteps;
  }
  public void setOp1ROffset (int a_op1ROffset) {
    op1ROffset = a_op1ROffset;
  }
  public void setOp2RSteps (int [] a_op2RSteps) {
    op2RSteps = a_op2RSteps;
  }
  public void setResultROffset (int a_resultROffset) {
    resultROffset = a_resultROffset;
  }
  public void setResultCSteps (int [] a_resultCSteps) {
    resultCSteps = a_resultCSteps;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setOp1Rows(Collection<DistributionRow> newOp1Rows) {
    op1Rows=new ArrayList<DistributionRow>(newOp1Rows);
  }

  public void add1Op1Rows(DistributionRow newOp1Rows) {
    op1Rows.add(newOp1Rows);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllOp1Rows(Collection<DistributionRow> newOp1Rows) {
    op1Rows.addAll(newOp1Rows);
  }

  public boolean remove1Op1Rows(DistributionRow newOp1Rows) {
    return op1Rows.remove(newOp1Rows);
  }
  public void setOp2COffset (int a_op2COffset) {
    op2COffset = a_op2COffset;
  }

  public void setDist1(Distribution newDist1) {
    dist1 = newDist1;
  }
  public void setOp2ROffset (int a_op2ROffset) {
    op2ROffset = a_op2ROffset;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }
  public void setCount (double a_count) {
    count = a_count;
  }

  public void setHasResult(Distribution newHasResult) {
    HasResult = newHasResult;
  }
  public void setCost (double a_cost) {
    cost = a_cost;
  }
  public void setNodeIndex (int a_nodeIndex) {
    nodeIndex = a_nodeIndex;
  }

  public void setDist2(Distribution newDist2) {
    dist2 = newDist2;
  }

  public void setNodes(NodeList newNodes) {
    nodes = newNodes;
  }
  public void setResultRSteps (int [] a_resultRSteps) {
    resultRSteps = a_resultRSteps;
  }
  public void setOp1RSteps (int [] a_op1RSteps) {
    op1RSteps = a_op1RSteps;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof TwoOpIndexStructure)) //covers o == null case
      return false;
    TwoOpIndexStructure other = (TwoOpIndexStructure)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "TwoOpIndexStructure");
      jsonObj.put("id", id);
      if (getOp2Rows() != null) {
        JSONArray jsonOp2Rows = new JSONArray();
        for (DistributionRow row: getOp2Rows()) {
          jsonOp2Rows.put(row.getId());
        }
        jsonObj.put("op2Rows", jsonOp2Rows);
      }
      jsonObj.put("resultCOffset", getResultCOffset());
      if (getResultRows() != null) {
        JSONArray jsonResultRows = new JSONArray();
        for (DistributionRow row: getResultRows()) {
          jsonResultRows.put(row.getId());
        }
        jsonObj.put("resultRows", jsonResultRows);
      }
      if (getOp1CSteps() != null) {
        JSONArray op1CStepsArray = new JSONArray();
        for (int  item : getOp1CSteps()) {
          op1CStepsArray.put(item);
        }
        jsonObj.put("op1CSteps", op1CStepsArray);
      }
      jsonObj.put("op1COffset", getOp1COffset());
      if (getOp2CSteps() != null) {
        JSONArray op2CStepsArray = new JSONArray();
        for (int  item : getOp2CSteps()) {
          op2CStepsArray.put(item);
        }
        jsonObj.put("op2CSteps", op2CStepsArray);
      }
      jsonObj.put("op1ROffset", getOp1ROffset());
      if (getOp2RSteps() != null) {
        JSONArray op2RStepsArray = new JSONArray();
        for (int  item : getOp2RSteps()) {
          op2RStepsArray.put(item);
        }
        jsonObj.put("op2RSteps", op2RStepsArray);
      }
      jsonObj.put("resultROffset", getResultROffset());
      if (getResultCSteps() != null) {
        JSONArray resultCStepsArray = new JSONArray();
        for (int  item : getResultCSteps()) {
          resultCStepsArray.put(item);
        }
        jsonObj.put("resultCSteps", resultCStepsArray);
      }
      if (getOp1Rows() != null) {
        JSONArray jsonOp1Rows = new JSONArray();
        for (DistributionRow row: getOp1Rows()) {
          jsonOp1Rows.put(row.getId());
        }
        jsonObj.put("op1Rows", jsonOp1Rows);
      }
      jsonObj.put("op2COffset", getOp2COffset());
      if (getDist1() != null) {
        jsonObj.put("dist1", getDist1().getId());
      }
      jsonObj.put("op2ROffset", getOp2ROffset());
      jsonObj.put("id", getId());
      jsonObj.put("count", getCount());
      if (getHasResult() != null) {
        jsonObj.put("HasResult", getHasResult().getId());
      }
      jsonObj.put("cost", getCost());
      jsonObj.put("nodeIndex", getNodeIndex());
      if (getDist2() != null) {
        jsonObj.put("dist2", getDist2().getId());
      }
      if (getNodes() != null) {
        jsonObj.put("nodes", getNodes().getId());
      }
      if (getResultRSteps() != null) {
        JSONArray resultRStepsArray = new JSONArray();
        for (int  item : getResultRSteps()) {
          resultRStepsArray.put(item);
        }
        jsonObj.put("resultRSteps", resultRStepsArray);
      }
      if (getOp1RSteps() != null) {
        JSONArray op1RStepsArray = new JSONArray();
        for (int  item : getOp1RSteps()) {
          op1RStepsArray.put(item);
        }
        jsonObj.put("op1RSteps", op1RStepsArray);
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "TwoOpIndexStructure");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getOp2Rows() != null) {
        JSONArray jsonOp2Rows = new JSONArray();
        for (DistributionRow row: getOp2Rows()) {
          jsonOp2Rows.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("op2Rows", jsonOp2Rows);
      }
      jsonObj.put("resultCOffset", getResultCOffset());
      if (getResultRows() != null) {
        JSONArray jsonResultRows = new JSONArray();
        for (DistributionRow row: getResultRows()) {
          jsonResultRows.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("resultRows", jsonResultRows);
      }
      if (getOp1CSteps() != null) {
        JSONArray op1CStepsArray = new JSONArray();
        for (int  item : getOp1CSteps()) {
          op1CStepsArray.put(item);
        }
        jsonObj.put("op1CSteps", op1CStepsArray);
      }
      jsonObj.put("op1COffset", getOp1COffset());
      if (getOp2CSteps() != null) {
        JSONArray op2CStepsArray = new JSONArray();
        for (int  item : getOp2CSteps()) {
          op2CStepsArray.put(item);
        }
        jsonObj.put("op2CSteps", op2CStepsArray);
      }
      jsonObj.put("op1ROffset", getOp1ROffset());
      if (getOp2RSteps() != null) {
        JSONArray op2RStepsArray = new JSONArray();
        for (int  item : getOp2RSteps()) {
          op2RStepsArray.put(item);
        }
        jsonObj.put("op2RSteps", op2RStepsArray);
      }
      jsonObj.put("resultROffset", getResultROffset());
      if (getResultCSteps() != null) {
        JSONArray resultCStepsArray = new JSONArray();
        for (int  item : getResultCSteps()) {
          resultCStepsArray.put(item);
        }
        jsonObj.put("resultCSteps", resultCStepsArray);
      }
      if (getOp1Rows() != null) {
        JSONArray jsonOp1Rows = new JSONArray();
        for (DistributionRow row: getOp1Rows()) {
          jsonOp1Rows.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("op1Rows", jsonOp1Rows);
      }
      jsonObj.put("op2COffset", getOp2COffset());
      if (getDist1() != null) {
        jsonObj.put("dist1", getDist1().asJSONTreeAux(written));
      }
      jsonObj.put("op2ROffset", getOp2ROffset());
      jsonObj.put("id", getId());
      jsonObj.put("count", getCount());
      if (getHasResult() != null) {
        jsonObj.put("HasResult", getHasResult().asJSONTreeAux(written));
      }
      jsonObj.put("cost", getCost());
      jsonObj.put("nodeIndex", getNodeIndex());
      if (getDist2() != null) {
        jsonObj.put("dist2", getDist2().asJSONTreeAux(written));
      }
      if (getNodes() != null) {
        jsonObj.put("nodes", getNodes().asJSONTreeAux(written));
      }
      if (getResultRSteps() != null) {
        JSONArray resultRStepsArray = new JSONArray();
        for (int  item : getResultRSteps()) {
          resultRStepsArray.put(item);
        }
        jsonObj.put("resultRSteps", resultRStepsArray);
      }
      if (getOp1RSteps() != null) {
        JSONArray op1RStepsArray = new JSONArray();
        for (int  item : getOp1RSteps()) {
          op1RStepsArray.put(item);
        }
        jsonObj.put("op1RSteps", op1RStepsArray);
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray op2RowsArray = jsonObj.optJSONArray("op2Rows");
      if(op2RowsArray != null) {
        ArrayList<DistributionRow> aListOfOp2Rows = new ArrayList<DistributionRow>(op2RowsArray.length());
        for (int i = 0; i < op2RowsArray.length(); i++) {
          int id = op2RowsArray.optInt(i);
          if (DistributionRowManager.getInstance().get(id) != null) {
            aListOfOp2Rows.add(DistributionRowManager.getInstance().get(id));
          }
        }
        setOp2Rows(aListOfOp2Rows);
      }
      if (!jsonObj.isNull("resultCOffset")) {
        setResultCOffset(jsonObj.optInt("resultCOffset"));
      }
      JSONArray resultRowsArray = jsonObj.optJSONArray("resultRows");
      if(resultRowsArray != null) {
        ArrayList<DistributionRow> aListOfResultRows = new ArrayList<DistributionRow>(resultRowsArray.length());
        for (int i = 0; i < resultRowsArray.length(); i++) {
          int id = resultRowsArray.optInt(i);
          if (DistributionRowManager.getInstance().get(id) != null) {
            aListOfResultRows.add(DistributionRowManager.getInstance().get(id));
          }
        }
        setResultRows(aListOfResultRows);
      }
      JSONArray op1CStepsArray = jsonObj.optJSONArray("op1CSteps");
      if (op1CStepsArray != null) {
        int[] aOp1CSteps = new int[op1CStepsArray.length()];
        for (int i = 0; i < op1CStepsArray.length(); i++) {
          aOp1CSteps[i] = op1CStepsArray.getInt(i);
        }
        setOp1CSteps(aOp1CSteps);
      }
      if (!jsonObj.isNull("op1COffset")) {
        setOp1COffset(jsonObj.optInt("op1COffset"));
      }
      JSONArray op2CStepsArray = jsonObj.optJSONArray("op2CSteps");
      if (op2CStepsArray != null) {
        int[] aOp2CSteps = new int[op2CStepsArray.length()];
        for (int i = 0; i < op2CStepsArray.length(); i++) {
          aOp2CSteps[i] = op2CStepsArray.getInt(i);
        }
        setOp2CSteps(aOp2CSteps);
      }
      if (!jsonObj.isNull("op1ROffset")) {
        setOp1ROffset(jsonObj.optInt("op1ROffset"));
      }
      JSONArray op2RStepsArray = jsonObj.optJSONArray("op2RSteps");
      if (op2RStepsArray != null) {
        int[] aOp2RSteps = new int[op2RStepsArray.length()];
        for (int i = 0; i < op2RStepsArray.length(); i++) {
          aOp2RSteps[i] = op2RStepsArray.getInt(i);
        }
        setOp2RSteps(aOp2RSteps);
      }
      if (!jsonObj.isNull("resultROffset")) {
        setResultROffset(jsonObj.optInt("resultROffset"));
      }
      JSONArray resultCStepsArray = jsonObj.optJSONArray("resultCSteps");
      if (resultCStepsArray != null) {
        int[] aResultCSteps = new int[resultCStepsArray.length()];
        for (int i = 0; i < resultCStepsArray.length(); i++) {
          aResultCSteps[i] = resultCStepsArray.getInt(i);
        }
        setResultCSteps(aResultCSteps);
      }
      JSONArray op1RowsArray = jsonObj.optJSONArray("op1Rows");
      if(op1RowsArray != null) {
        ArrayList<DistributionRow> aListOfOp1Rows = new ArrayList<DistributionRow>(op1RowsArray.length());
        for (int i = 0; i < op1RowsArray.length(); i++) {
          int id = op1RowsArray.optInt(i);
          if (DistributionRowManager.getInstance().get(id) != null) {
            aListOfOp1Rows.add(DistributionRowManager.getInstance().get(id));
          }
        }
        setOp1Rows(aListOfOp1Rows);
      }
      if (!jsonObj.isNull("op2COffset")) {
        setOp2COffset(jsonObj.optInt("op2COffset"));
      }
      if (!jsonObj.isNull("dist1")) {
        int dist1Id = jsonObj.optInt("dist1");
        Distribution value = DistributionManager.getInstance().get(dist1Id);
        if(value != null) {
            setDist1(value);
        }
      }
      if (!jsonObj.isNull("op2ROffset")) {
        setOp2ROffset(jsonObj.optInt("op2ROffset"));
      }
      if (!jsonObj.isNull("count")) {
        setCount(jsonObj.optDouble("count"));
      }
      if (!jsonObj.isNull("HasResult")) {
        int HasResultId = jsonObj.optInt("HasResult");
        Distribution value = DistributionManager.getInstance().get(HasResultId);
        if(value != null) {
            setHasResult(value);
        }
      }
      if (!jsonObj.isNull("cost")) {
        setCost(jsonObj.optDouble("cost"));
      }
      if (!jsonObj.isNull("nodeIndex")) {
        setNodeIndex(jsonObj.optInt("nodeIndex"));
      }
      if (!jsonObj.isNull("dist2")) {
        int dist2Id = jsonObj.optInt("dist2");
        Distribution value = DistributionManager.getInstance().get(dist2Id);
        if(value != null) {
            setDist2(value);
        }
      }
      if (!jsonObj.isNull("nodes")) {
        int nodesId = jsonObj.optInt("nodes");
        NodeList value = NodeListManager.getInstance().get(nodesId);
        if(value != null) {
            setNodes(value);
        }
      }
      JSONArray resultRStepsArray = jsonObj.optJSONArray("resultRSteps");
      if (resultRStepsArray != null) {
        int[] aResultRSteps = new int[resultRStepsArray.length()];
        for (int i = 0; i < resultRStepsArray.length(); i++) {
          aResultRSteps[i] = resultRStepsArray.getInt(i);
        }
        setResultRSteps(aResultRSteps);
      }
      JSONArray op1RStepsArray = jsonObj.optJSONArray("op1RSteps");
      if (op1RStepsArray != null) {
        int[] aOp1RSteps = new int[op1RStepsArray.length()];
        for (int i = 0; i < op1RStepsArray.length(); i++) {
          aOp1RSteps[i] = op1RStepsArray.getInt(i);
        }
        setOp1RSteps(aOp1RSteps);
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }

}
