/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class ClassModel extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(ClassModel.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  private ArrayList<Arc> hasArcs = new ArrayList<Arc>();
  protected PropertySet hasPropertySet = null;

  protected NodeList hasDomainNodes = null;


  /** if no arg, assume from db **/
  public ClassModel() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public ClassModel(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
    hasArcs= new ArrayList<Arc>(0);
  }
  public ClassModel(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
    hasArcs= new ArrayList<Arc>(0);
  }
  public List<Arc> getHasArcs() {
      return hasArcs;
  }
  public boolean HasPropertySetIsResident() {
      return true;
  }
  public PropertySet getHasPropertySet() {

    return hasPropertySet;
  }
  public int getHasPropertySetInternalId() {
    if (hasPropertySet == null) {
      return -1;
    } else { 
      return hasPropertySet.getId();
    }
  }
  public int getId() {
    return id;
  }
  public boolean HasDomainNodesIsResident() {
      return true;
  }
  public NodeList getHasDomainNodes() {

    return hasDomainNodes;
  }
  public int getHasDomainNodesInternalId() {
    if (hasDomainNodes == null) {
      return -1;
    } else { 
      return hasDomainNodes.getId();
    }
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasArcs(Collection<Arc> newHasArcs) {
    hasArcs=new ArrayList<Arc>(newHasArcs);
  }

  public void add1HasArcs(Arc newHasArcs) {
    hasArcs.add(newHasArcs);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasArcs(Collection<Arc> newHasArcs) {
    hasArcs.addAll(newHasArcs);
  }

  public boolean remove1HasArcs(Arc newHasArcs) {
    return hasArcs.remove(newHasArcs);
  }

  public void setHasPropertySet(PropertySet newHasPropertySet) {
    hasPropertySet = newHasPropertySet;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
        ClassModelManager.getInstance().putInCache(this);
      }
  }

  public void setHasDomainNodes(NodeList newHasDomainNodes) {
    hasDomainNodes = newHasDomainNodes;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof ClassModel)) //covers o == null case
      return false;
    ClassModel other = (ClassModel)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "ClassModel");
      jsonObj.put("id", id);
      if (getHasArcs() != null) {
        JSONArray jsonHasArcs = new JSONArray();
        for (Arc row: getHasArcs()) {
          jsonHasArcs.put(row.getId());
        }
        jsonObj.put("hasArcs", jsonHasArcs);
      }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().getId());
      }
      jsonObj.put("id", getId());
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "ClassModel");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getHasArcs() != null) {
        JSONArray jsonHasArcs = new JSONArray();
        for (Arc row: getHasArcs()) {
          jsonHasArcs.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasArcs", jsonHasArcs);
      }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray hasArcsArray = jsonObj.optJSONArray("hasArcs");
      if(hasArcsArray != null) {
        ArrayList<Arc> aListOfHasArcs = new ArrayList<Arc>(hasArcsArray.length());
        for (int i = 0; i < hasArcsArray.length(); i++) {
          int id = hasArcsArray.optInt(i);
          if (ArcManager.getInstance().get(id) != null) {
            aListOfHasArcs.add(ArcManager.getInstance().get(id));
          }
        }
        setHasArcs(aListOfHasArcs);
      }
      if (!jsonObj.isNull("hasPropertySet")) {
        int hasPropertySetId = jsonObj.optInt("hasPropertySet");
        PropertySet value = PropertySetManager.getInstance().get(hasPropertySetId);
        if(value != null) {
            setHasPropertySet(value);
        }
      }
      if (!jsonObj.isNull("hasDomainNodes")) {
        int hasDomainNodesId = jsonObj.optInt("hasDomainNodes");
        NodeList value = NodeListManager.getInstance().get(hasDomainNodesId);
        if(value != null) {
            setHasDomainNodes(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }

}
