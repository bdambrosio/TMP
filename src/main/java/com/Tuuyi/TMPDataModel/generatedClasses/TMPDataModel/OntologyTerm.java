/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class OntologyTerm extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(OntologyTerm.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  private ArrayList<ItemProjection> hasItems = new ArrayList<ItemProjection>();
  String kind;
  protected ArrayList<OntologyRelation> asArg1In = new ArrayList<OntologyRelation>(0);

  public void setAsArg1InRawValueInternal(String rawVal) {
  }

  long recursiveItemCount;
  protected ArrayList<OntologyRelation> asArg2In = new ArrayList<OntologyRelation>(0);

  public void setAsArg2InRawValueInternal(String rawVal) {
  }

  String hasValue;

  /** if no arg, assume from db **/
  public OntologyTerm() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public OntologyTerm(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
    hasItems= new ArrayList<ItemProjection>(0);
  }
  public OntologyTerm(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
    hasItems= new ArrayList<ItemProjection>(0);
  }
  public List<ItemProjection> getHasItems() {
      return hasItems;
  }
  public String getKind() {
    return kind;
  }
  public boolean asArg1InAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsAsArg1In(OntologyRelation value) {
      return asArg1In.contains(value);
  }

  public ArrayList<OntologyRelation> getAsArg1In() {
      return asArg1In;
  }
  public long getRecursiveItemCount() {
    return recursiveItemCount;
  }
  public int getId() {
    return id;
  }
  public boolean asArg2InAllResident() {
      return true;
  }

  /** returns true if this object contains the given object without accessing the database **/
  public boolean containsAsArg2In(OntologyRelation value) {
      return asArg2In.contains(value);
  }

  public ArrayList<OntologyRelation> getAsArg2In() {
      return asArg2In;
  }
  public String getHasValue() {
    return hasValue;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setHasItems(Collection<ItemProjection> newHasItems) {
    hasItems=new ArrayList<ItemProjection>(newHasItems);
  }

  public void add1HasItems(ItemProjection newHasItems) {
    hasItems.add(newHasItems);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllHasItems(Collection<ItemProjection> newHasItems) {
    hasItems.addAll(newHasItems);
  }

  public boolean remove1HasItems(ItemProjection newHasItems) {
    return hasItems.remove(newHasItems);
  }
  public void setKind (String a_kind) {
    kind = a_kind;
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setAsArg1In(Collection<OntologyRelation> newAsArg1In) {
    asArg1In=new ArrayList<OntologyRelation>(newAsArg1In);
  }

  public void add1AsArg1In(OntologyRelation newAsArg1In) {
    asArg1In.add(newAsArg1In);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllAsArg1In(Collection<OntologyRelation> newAsArg1In) {
    asArg1In.addAll(newAsArg1In);
  }

  public boolean remove1AsArg1In(OntologyRelation newAsArg1In) {
    return asArg1In.remove(newAsArg1In);
  }
  public void setRecursiveItemCount (long a_recursiveItemCount) {
    recursiveItemCount = a_recursiveItemCount;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void setAsArg2In(Collection<OntologyRelation> newAsArg2In) {
    asArg2In=new ArrayList<OntologyRelation>(newAsArg2In);
  }

  public void add1AsArg2In(OntologyRelation newAsArg2In) {
    asArg2In.add(newAsArg2In);
  }

  /** note that this method does not check for duplicates, which may cause a DB error */
  public void addAllAsArg2In(Collection<OntologyRelation> newAsArg2In) {
    asArg2In.addAll(newAsArg2In);
  }

  public boolean remove1AsArg2In(OntologyRelation newAsArg2In) {
    return asArg2In.remove(newAsArg2In);
  }
  public void setHasValue (String a_hasValue) {
    hasValue = a_hasValue;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof OntologyTerm)) //covers o == null case
      return false;
    OntologyTerm other = (OntologyTerm)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "OntologyTerm");
      jsonObj.put("id", id);
      if (getHasItems() != null) {
        JSONArray jsonHasItems = new JSONArray();
        for (ItemProjection row: getHasItems()) {
          jsonHasItems.put(row.getId());
        }
        jsonObj.put("hasItems", jsonHasItems);
      }
      jsonObj.put("kind", getKind());
       if (getAsArg1In() != null) {
         String AsArg1InAsString = "";
         for (OntologyRelation AsArg1Initem: getAsArg1In()) {
           AsArg1InAsString += AsArg1Initem.getId() + ",";
           AsArg1InAsString.replaceFirst(",$", "");
         }
         jsonObj.put("asArg1In", AsArg1InAsString);
       }
      jsonObj.put("recursiveItemCount", getRecursiveItemCount());
      jsonObj.put("id", getId());
       if (getAsArg2In() != null) {
         String AsArg2InAsString = "";
         for (OntologyRelation AsArg2Initem: getAsArg2In()) {
           AsArg2InAsString += AsArg2Initem.getId() + ",";
           AsArg2InAsString.replaceFirst(",$", "");
         }
         jsonObj.put("asArg2In", AsArg2InAsString);
       }
      jsonObj.put("hasValue", getHasValue());
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "OntologyTerm");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getHasItems() != null) {
        JSONArray jsonHasItems = new JSONArray();
        for (ItemProjection row: getHasItems()) {
          jsonHasItems.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasItems", jsonHasItems);
      }
      jsonObj.put("kind", getKind());
       if (getAsArg1In() != null) {
         String AsArg1InAsString = "";
         for (OntologyRelation AsArg1Initem: getAsArg1In()) {
           AsArg1InAsString += AsArg1Initem.getId() + ",";
           AsArg1InAsString.replaceFirst(",$", "");
         }
         jsonObj.put("asArg1In", AsArg1InAsString);
       }
      jsonObj.put("recursiveItemCount", getRecursiveItemCount());
      jsonObj.put("id", getId());
       if (getAsArg2In() != null) {
         String AsArg2InAsString = "";
         for (OntologyRelation AsArg2Initem: getAsArg2In()) {
           AsArg2InAsString += AsArg2Initem.getId() + ",";
           AsArg2InAsString.replaceFirst(",$", "");
         }
         jsonObj.put("asArg2In", AsArg2InAsString);
       }
      jsonObj.put("hasValue", getHasValue());
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      JSONArray hasItemsArray = jsonObj.optJSONArray("hasItems");
      if(hasItemsArray != null) {
        ArrayList<ItemProjection> aListOfHasItems = new ArrayList<ItemProjection>(hasItemsArray.length());
        for (int i = 0; i < hasItemsArray.length(); i++) {
          int id = hasItemsArray.optInt(i);
          if (ItemProjectionManager.getInstance().get(id) != null) {
            aListOfHasItems.add(ItemProjectionManager.getInstance().get(id));
          }
        }
        setHasItems(aListOfHasItems);
      }
      if (!jsonObj.isNull("kind")) {
        setKind(jsonObj.optString("kind"));
      }
      if (!jsonObj.isNull("asArg1In")) {
      String [] asArg1InAsStrings = jsonObj.optString("asArg1In").split(",");
      ArrayList<OntologyRelation> asArg1InValues = new ArrayList<OntologyRelation>(asArg1InAsStrings.length);
      for (String asArg1InItemId: asArg1InAsStrings) {
      if (asArg1InItemId != null && OntologyRelationManager.getInstance().get(Integer.parseInt(asArg1InItemId)) != null) {
          asArg1InValues.add(OntologyRelationManager.getInstance().get(Integer.parseInt(asArg1InItemId)));
        }
      }
      asArg1In = asArg1InValues;
      }
      if (!jsonObj.isNull("recursiveItemCount")) {
        setRecursiveItemCount(jsonObj.optLong("recursiveItemCount"));
      }
      if (!jsonObj.isNull("asArg2In")) {
      String [] asArg2InAsStrings = jsonObj.optString("asArg2In").split(",");
      ArrayList<OntologyRelation> asArg2InValues = new ArrayList<OntologyRelation>(asArg2InAsStrings.length);
      for (String asArg2InItemId: asArg2InAsStrings) {
      if (asArg2InItemId != null && OntologyRelationManager.getInstance().get(Integer.parseInt(asArg2InItemId)) != null) {
          asArg2InValues.add(OntologyRelationManager.getInstance().get(Integer.parseInt(asArg2InItemId)));
        }
      }
      asArg2In = asArg2InValues;
      }
      if (!jsonObj.isNull("hasValue")) {
        setHasValue(jsonObj.optString("hasValue"));
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


    public OntologyTerm(String name) {
      this.setHasValue(name);
    }
  
  public String toString() {
    return getHasValue();
  }
  
  public void initializeRecursiveItemCount() {
    setRecursiveItemCount(-1);
  }
  
  public long computeRecursiveItemCount() {
    long count = 0;
    count = getHasItems().size();
    for (OntologyRelation relation: getAsArg2In()) {
      if (relation.getRelation() == OntologyRelation.GENERALIZATION_RELATION) {
        if (relation.getHasArg1().getRecursiveItemCount() < 0) {
          relation.getHasArg1().computeRecursiveItemCount();
        }
        count += relation.getHasArg1().getRecursiveItemCount();
        
      }
    }
    setRecursiveItemCount(count);
    return count;
  }

}
