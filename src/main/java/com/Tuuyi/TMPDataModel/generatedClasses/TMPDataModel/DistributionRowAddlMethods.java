/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
//import
import java.io.BufferedWriter;
//import
import java.io.IOException;
//import
import java.lang.reflect.Method;
//import
import org.json.*;

import java.util.concurrent.ConcurrentHashMap;

public class DistributionRowAddlMethods extends DistributionRow {

  public static DistributionRow newRow(int [] a_indexVector, double [] a_row) {
    DistributionRow row = new DistributionRow();
    row.setIndexVector(a_indexVector);
    row.setRow(a_row);
    return row;
  }
  
  public String indexVectorAsString() {
    StringBuffer sb = new StringBuffer();
    sb.append('[');
    if (getIndexVector() != null) {
      for (int i = 0; i < getIndexVector().length; i++) {
        if (i > 0) {
          sb.append(' ');
        }
        sb.append(getIndexVector()[i]);
      }
    }
    sb.append(']');
    return sb.toString();
  }
  
  public boolean caseMatch(int [] a_indexVector) {
    int [] iv = getIndexVector();
    if (iv.length == 0 && (a_indexVector == null || a_indexVector.length == 0)) {
      return true;
    }
    if (a_indexVector == null || a_indexVector.length != iv.length) {
      return false;
    }
    for (int i = 0; i < iv.length; i++) {
      if (a_indexVector[i] != iv[i]) {
        return false;
      }
    }
    return true;
  }
  
  public double normalize() {
    double norm = 0;
    for (int i = 0; i < row.length; i++) {
      norm += row[i];
    }
    if (norm > 0.0) {
      for (int i = 0; i < row.length; i++) {
        row[i] /= norm;
      }
    }
    return norm;
  }

  public double zero() {
    for (int i = 0; i < row.length; i++) {
      row[i] = 0.0;
    }
    return 0.0;
  }

  public long export(BufferedWriter writer, JSONObject json, HashMap <Object, Long> objectIndex) 
      throws IOException, JSONException {
    if (objectIndex.containsKey(this)) {
      return objectIndex.get(this);
    } else {
      long rowId = GraphTMP.nextJSONId();
      objectIndex.put(this, rowId);
      JSONObject rowJSON = asJSON();
      JSONArray jsonRows = new JSONArray();
      //if (getHasDistributionRows() != null) {
      //  for (DistributionRow row: getHasDistributionRows()) {
      //jsonDistributions.put(dist.export(writer, dictionary, localDictionary));
      // }
      // distJSON.put("hasDistributions", jsonRows);
      json.put(""+rowId, rowJSON);
      //}
      return rowId;
    }
  }


}
