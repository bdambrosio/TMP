/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;
import com.Tuuyi.TMPDataModel.DefaultProjector;

public class Projection extends  GraphTMP {

  protected static final Logger logWriter = Logger.getLogger(Projection.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  protected CatalogOntology usesOntology = null;

  protected Abstraction hasAbstraction = null;


  /** if no arg, assume from db **/
  public Projection() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public Projection(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public Projection(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public boolean UsesOntologyIsResident() {
      return true;
  }
  public CatalogOntology getUsesOntology() {

    return usesOntology;
  }
  public int getUsesOntologyInternalId() {
    if (usesOntology == null) {
      return -1;
    } else { 
      return usesOntology.getId();
    }
  }
  public int getId() {
    return id;
  }
  public boolean HasAbstractionIsResident() {
      return true;
  }
  public Abstraction getHasAbstraction() {

    return hasAbstraction;
  }
  public int getHasAbstractionInternalId() {
    if (hasAbstraction == null) {
      return -1;
    } else { 
      return hasAbstraction.getId();
    }
  }

  public void setUsesOntology(CatalogOntology newUsesOntology) {
    usesOntology = newUsesOntology;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }

  public void setHasAbstraction(Abstraction newHasAbstraction) {
    hasAbstraction = newHasAbstraction;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof Projection)) //covers o == null case
      return false;
    Projection other = (Projection)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Projection");
      jsonObj.put("id", id);
      if (getUsesOntology() != null) {
        jsonObj.put("usesOntology", getUsesOntology().getId());
      }
      jsonObj.put("id", getId());
      if (getHasAbstraction() != null) {
        jsonObj.put("hasAbstraction", getHasAbstraction().getId());
      }
      if (getContext() != null) {
        jsonObj.put("context", getContext().getId());
      }
      if (getOutputNamespace() != null) {
        jsonObj.put("outputNamespace", getOutputNamespace().getId());
      }
      if (getInputNamespace() != null) {
        jsonObj.put("inputNamespace", getInputNamespace().getId());
      }
      if (getHasDistributions() != null) {
        JSONArray jsonHasDistributions = new JSONArray();
        for (Distribution row: getHasDistributions()) {
          jsonHasDistributions.put(row.getId());
        }
        jsonObj.put("hasDistributions", jsonHasDistributions);
      }
      jsonObj.put("id", getId());
      jsonObj.put("id", getId());
       if (getHasInstances() != null) {
         String HasInstancesAsString = "";
         for (Instance HasInstancesitem: getHasInstances()) {
           HasInstancesAsString += HasInstancesitem.getId() + ",";
           HasInstancesAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasInstances", HasInstancesAsString);
       }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().getId());
      }
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Projection");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getUsesOntology() != null) {
        jsonObj.put("usesOntology", getUsesOntology().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      if (getHasAbstraction() != null) {
        jsonObj.put("hasAbstraction", getHasAbstraction().asJSONTreeAux(written));
      }
      if (getContext() != null) {
        jsonObj.put("context", getContext().asJSONTreeAux(written));
      }
      if (getOutputNamespace() != null) {
        jsonObj.put("outputNamespace", getOutputNamespace().asJSONTreeAux(written));
      }
      if (getInputNamespace() != null) {
        jsonObj.put("inputNamespace", getInputNamespace().asJSONTreeAux(written));
      }
      if (getHasDistributions() != null) {
        JSONArray jsonHasDistributions = new JSONArray();
        for (Distribution row: getHasDistributions()) {
          jsonHasDistributions.put(row.asJSONTreeAux(written));
        }
        jsonObj.put("hasDistributions", jsonHasDistributions);
      }
      jsonObj.put("id", getId());
      jsonObj.put("id", getId());
       if (getHasInstances() != null) {
         String HasInstancesAsString = "";
         for (Instance HasInstancesitem: getHasInstances()) {
           HasInstancesAsString += HasInstancesitem.getId() + ",";
           HasInstancesAsString.replaceFirst(",$", "");
         }
         jsonObj.put("hasInstances", HasInstancesAsString);
       }
      if (getHasPropertySet() != null) {
        jsonObj.put("hasPropertySet", getHasPropertySet().asJSONTreeAux(written));
      }
      if (getHasDomainNodes() != null) {
        jsonObj.put("hasDomainNodes", getHasDomainNodes().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("usesOntology")) {
        int usesOntologyId = jsonObj.optInt("usesOntology");
        CatalogOntology value = CatalogOntologyManager.getInstance().get(usesOntologyId);
        if(value != null) {
            setUsesOntology(value);
        }
      }
      if (!jsonObj.isNull("hasAbstraction")) {
        int hasAbstractionId = jsonObj.optInt("hasAbstraction");
        Abstraction value = AbstractionManager.getInstance().get(hasAbstractionId);
        if(value != null) {
            setHasAbstraction(value);
        }
      }
      if (!jsonObj.isNull("context")) {
        int contextId = jsonObj.optInt("context");
        GraphContext value = GraphContextManager.getInstance().get(contextId);
        if(value != null) {
            setContext(value);
        }
      }
      if (!jsonObj.isNull("outputNamespace")) {
        int outputNamespaceId = jsonObj.optInt("outputNamespace");
        Namespace value = NamespaceManager.getInstance().get(outputNamespaceId);
        if(value != null) {
            setOutputNamespace(value);
        }
      }
      if (!jsonObj.isNull("inputNamespace")) {
        int inputNamespaceId = jsonObj.optInt("inputNamespace");
        Namespace value = NamespaceManager.getInstance().get(inputNamespaceId);
        if(value != null) {
            setInputNamespace(value);
        }
      }
      JSONArray hasDistributionsArray = jsonObj.optJSONArray("hasDistributions");
      if(hasDistributionsArray != null) {
        ArrayList<Distribution> aListOfHasDistributions = new ArrayList<Distribution>(hasDistributionsArray.length());
        for (int i = 0; i < hasDistributionsArray.length(); i++) {
          int id = hasDistributionsArray.optInt(i);
          if (DistributionManager.getInstance().get(id) != null) {
            aListOfHasDistributions.add(DistributionManager.getInstance().get(id));
          }
        }
        setHasDistributions(aListOfHasDistributions);
      }
      if (!jsonObj.isNull("hasInstances")) {
      String [] hasInstancesAsStrings = jsonObj.optString("hasInstances").split(",");
      ArrayList<Instance> hasInstancesValues = new ArrayList<Instance>(hasInstancesAsStrings.length);
      for (String hasInstancesItemId: hasInstancesAsStrings) {
      if (hasInstancesItemId != null && InstanceManager.getInstance().get(Integer.parseInt(hasInstancesItemId)) != null) {
          hasInstancesValues.add(InstanceManager.getInstance().get(Integer.parseInt(hasInstancesItemId)));
        }
      }
      hasInstances = hasInstancesValues;
      }
      if (!jsonObj.isNull("hasPropertySet")) {
        int hasPropertySetId = jsonObj.optInt("hasPropertySet");
        PropertySet value = PropertySetManager.getInstance().get(hasPropertySetId);
        if(value != null) {
            setHasPropertySet(value);
        }
      }
      if (!jsonObj.isNull("hasDomainNodes")) {
        int hasDomainNodesId = jsonObj.optInt("hasDomainNodes");
        NodeList value = NodeListManager.getInstance().get(hasDomainNodesId);
        if(value != null) {
            setHasDomainNodes(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }

  static {
    initSampleOrder();
  }

  private Projector projector;
  //DL    public Projection(Projector p, Abstraction a) {
  //DL      projector = p;
  //DL      setHasAbstraction(a);
  //DL    }

  //DL    public Projection(Abstraction a) {
  //DL      projector = new DefaultProjector();
  //DL      setHasAbstraction(a);
  //DL    }

  public Projector getProjector() {
    return projector;
  }

  public void setProjector(Projector projector) {
    this.projector = projector;
  }

  public void useDefaultProjector() {
    this.projector = new DefaultProjector(getUsesOntology());
  }

  public long inititalize(Abstraction a, Iterator<CatalogItem> catalog) {
    setHasAbstraction(a);
    long itemCount = 0;
    while (catalog.hasNext()) {
      indexItem(a.abstractItem(catalog.next()));
      itemCount++;
    }
    return itemCount;
  }

  public Collection<ScoredTerm> indexItem(AbstractItem ai) {
    // an ai contains merely an unstructured collection of scoredTokens
    // ontology parses into terms, extending ontology as needed

    ItemProjection item = getUsesOntology().index(ai);
    Collection<ScoredTerm> terms = item.getHasOntologyTerms();
    // now index the item under each term
    for (ScoredTerm term: terms) {
      term.getForTerm().add1HasItems(item);
    }
    return terms;
  }

  static HashMap <Integer, int []> samplingOrder;

  static void initSampleOrder() {
    samplingOrder = new HashMap <Integer, int []> ();
    for (int i = 1; i < 2400000; i=i*2) {
      ArrayList <SampleOrder> sampling = new ArrayList<SampleOrder> (i);
      for (int j = 0; j < i; j++) {
        sampling.add(new SampleOrder(j, Math.random()));
      }
      Collections.sort(sampling);
      int [] ordering = new int[sampling.size()];
      for (int j = 0; j < sampling.size(); j++) {
        ordering[j] = sampling.get(j).sampleIndex;
      }
      samplingOrder.put((int)(Math.log(i)/Math.log(2.0)), ordering);
    }
  }
  
  static int [] getSampleOrder(int size) {
    int index = (int)Math.ceil((Math.log(size)/Math.log(2.0)));
    return samplingOrder.get(index);
  }
  
  public InstanceSparseGraphMapper newMapper(Collector source, Collector sink) {
    InstanceSparseGraphMapper mapper = new InstanceSparseGraphMapper();
    mapper.setInputNamespace(inputNamespace);
    mapper.setOutputNamespace(outputNamespace);
    mapper.setHasSource(source);
    mapper.setHasSink(sink);
    mapper.setHasModel(this);
    mapper.clear();
    return mapper;
  }



  static class SampleOrder implements Comparable {
    int sampleIndex;
    double order;

    SampleOrder (int s, double p) {
      sampleIndex = s;
      order = p;
    }

    public int compareTo(Object arg0) {
      if (SampleOrder.class.isInstance(arg0)) {
        if (order > ((SampleOrder)arg0).order) {
          return -1;
        } else if (order < ((SampleOrder)arg0).order) {
          return 1;
        }
      }
      return 0;
    }

  }

}
