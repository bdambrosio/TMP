/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

public class WeightedSubjectArc extends  SubjectArc {

  protected static final Logger logWriter = Logger.getLogger(WeightedSubjectArc.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  double score;
  double count;
  String [] hasTail;
  String hasHead;
  double rawCount;
  long propagationMark;
  long firstSeen;

  /** if no arg, assume from db **/
  public WeightedSubjectArc() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public WeightedSubjectArc(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public WeightedSubjectArc(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public double getScore() {
    return score;
  }
  public double getCount() {
    return count;
  }
  public String [] getHasTail() {
    return hasTail;
  }
  public int getId() {
    return id;
  }
  public String getHasHead() {
    return hasHead;
  }
  public double getRawCount() {
    return rawCount;
  }
  public long getPropagationMark() {
    return propagationMark;
  }
  public long getFirstSeen() {
    return firstSeen;
  }
  public void setScore (double a_score) {
    score = a_score;
  }
  public void setCount (double a_count) {
    count = a_count;
  }
  public void setHasTail (String [] a_hasTail) {
    hasTail = a_hasTail;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }
  public void setHasHead (String a_hasHead) {
    hasHead = a_hasHead;
  }
  public void setRawCount (double a_rawCount) {
    rawCount = a_rawCount;
  }
  public void setPropagationMark (long a_propagationMark) {
    propagationMark = a_propagationMark;
  }
  public void setFirstSeen (long a_firstSeen) {
    firstSeen = a_firstSeen;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof WeightedSubjectArc)) //covers o == null case
      return false;
    WeightedSubjectArc other = (WeightedSubjectArc)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "WeightedSubjectArc");
      jsonObj.put("id", id);
      jsonObj.put("score", getScore());
      jsonObj.put("count", getCount());
      if (getHasTail() != null) {
        JSONArray hasTailArray = new JSONArray();
        for (String item : getHasTail()) {
          hasTailArray.put(item);
        }
        jsonObj.put("hasTail", hasTailArray);
      }
      jsonObj.put("id", getId());
      jsonObj.put("hasHead", getHasHead());
      jsonObj.put("rawCount", getRawCount());
      jsonObj.put("propagationMark", getPropagationMark());
      jsonObj.put("firstSeen", getFirstSeen());
      jsonObj.put("id", getId());
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "WeightedSubjectArc");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      jsonObj.put("score", getScore());
      jsonObj.put("count", getCount());
      if (getHasTail() != null) {
        JSONArray hasTailArray = new JSONArray();
        for (String item : getHasTail()) {
          hasTailArray.put(item);
        }
        jsonObj.put("hasTail", hasTailArray);
      }
      jsonObj.put("id", getId());
      jsonObj.put("hasHead", getHasHead());
      jsonObj.put("rawCount", getRawCount());
      jsonObj.put("propagationMark", getPropagationMark());
      jsonObj.put("firstSeen", getFirstSeen());
      jsonObj.put("id", getId());
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("score")) {
        setScore(jsonObj.optDouble("score"));
      }
      if (!jsonObj.isNull("count")) {
        setCount(jsonObj.optDouble("count"));
      }
      JSONArray hasTailArray = jsonObj.optJSONArray("hasTail");
      if (hasTailArray != null) {
        String[] aHasTail = new String[hasTailArray.length()];
        for (int i = 0; i < hasTailArray.length(); i++) {
          aHasTail[i] = hasTailArray.getString(i);
        }
        setHasTail(aHasTail);
      }
      if (!jsonObj.isNull("hasHead")) {
        setHasHead(jsonObj.optString("hasHead"));
      }
      if (!jsonObj.isNull("rawCount")) {
        setRawCount(jsonObj.optDouble("rawCount"));
      }
      if (!jsonObj.isNull("propagationMark")) {
        setPropagationMark(jsonObj.optLong("propagationMark"));
      }
      if (!jsonObj.isNull("firstSeen")) {
        setFirstSeen(jsonObj.optLong("firstSeen"));
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  public String getTailAsString() {
    StringBuffer asString = new StringBuffer(64);
    if (getHasTail() != null) {
      for (int i = 0; i < getHasTail().length; i++) {
        asString.append(getHasTail()[i]);
        if (i < getHasTail().length-1) {
          asString.append(",");
        }
      }
    }
    return asString.toString();
  }
  
  public boolean hasTailElement(String tailElementQuery) {
    if (getHasTail() != null) {
      for (String tailElement: getHasTail()) {
        if (tailElementQuery.equals(tailElement)) {
          return true;
        }
      }
    }
    return false;
  }
  
  public String jointTailString(WeightedSubjectArc arc2) {
    StringBuffer asString = new StringBuffer(getTailAsString());
    for (String tail: arc2.getHasTail()) {
        if(!hasTailElement(tail)) {
          asString.append(",");
          asString.append(tail);
        }
      }
    return asString.toString();
  }

  public String [] jointTail(WeightedSubjectArc arc2) {
    ArrayList<String> jointTailArrayList = new ArrayList<String> ();
    for (String tail: getHasTail()) {
      jointTailArrayList.add(tail);
    }
    
    for (String tail: arc2.getHasTail()) {
      if(!hasTailElement(tail)) {
        jointTailArrayList.add(tail);
      }
    }
    String [] jointTail = new String[jointTailArrayList.size()];
    for (int i = 0; i < jointTailArrayList.size(); i++) {
      jointTail[i] = jointTailArrayList.get(i);
    }
    return jointTail;
  }
}
