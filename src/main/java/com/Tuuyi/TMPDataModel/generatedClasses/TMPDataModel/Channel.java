/* generated by writeJava methods in Workspace */
package com.Tuuyi.TMPDataModel.generatedClasses.TMPDataModel;

import com.Tuuyi.TDM.*;
import org.apache.log4j.Logger;
import java.util.*;
import java.lang.reflect.Method;
import org.json.*;
import java.util.concurrent.ConcurrentHashMap;

import java.util.ArrayList;
import java.util.Iterator;

public class Channel extends DomainConcept {

  protected static final Logger logWriter = Logger.getLogger(Channel.class.getName());
  private static final boolean persistant = false;

  public void inMemoryOnly(boolean local) {inMemoryOnly = local;}
  public boolean getInMemoryOnly() {return inMemoryOnly;}
  public boolean isPersistant() {return persistant;}

  public static boolean isPersistantClass() {return persistant;}

  protected Namespace filterNamespace = null;

  protected Beliefspace beliefspace = null;

  protected Collector hasDestinationCollector = null;

  protected Namespace namespace = null;

  protected GraphContext hasOutputContext = null;


  /** if no arg, assume from db **/
  public Channel() {
    this(true);
  }
  /** if from DB, set nonFunctional slot wrappers to stub **/
  /**    so subsequent slot get will do retrieval         **/
  public Channel(boolean fromDB) {
    super(Workspace.getCurrentWorkspace(), fromDB);
  }
  public Channel(Workspace workspace, boolean fromDB) {
    super(workspace, fromDB);
  }
  public boolean FilterNamespaceIsResident() {
      return true;
  }
  public Namespace getFilterNamespace() {

    return filterNamespace;
  }
  public int getFilterNamespaceInternalId() {
    if (filterNamespace == null) {
      return -1;
    } else { 
      return filterNamespace.getId();
    }
  }
  public boolean BeliefspaceIsResident() {
      return true;
  }
  public Beliefspace getBeliefspace() {

    return beliefspace;
  }
  public int getBeliefspaceInternalId() {
    if (beliefspace == null) {
      return -1;
    } else { 
      return beliefspace.getId();
    }
  }
  public boolean HasDestinationCollectorIsResident() {
      return true;
  }
  public Collector getHasDestinationCollector() {

    return hasDestinationCollector;
  }
  public int getHasDestinationCollectorInternalId() {
    if (hasDestinationCollector == null) {
      return -1;
    } else { 
      return hasDestinationCollector.getId();
    }
  }
  public boolean NamespaceIsResident() {
      return true;
  }
  public Namespace getNamespace() {

    return namespace;
  }
  public int getNamespaceInternalId() {
    if (namespace == null) {
      return -1;
    } else { 
      return namespace.getId();
    }
  }
  public int getId() {
    return id;
  }
  public boolean HasOutputContextIsResident() {
      return true;
  }
  public GraphContext getHasOutputContext() {

    return hasOutputContext;
  }
  public int getHasOutputContextInternalId() {
    if (hasOutputContext == null) {
      return -1;
    } else { 
      return hasOutputContext.getId();
    }
  }

  public void setFilterNamespace(Namespace newFilterNamespace) {
    filterNamespace = newFilterNamespace;
  }

  public void setBeliefspace(Beliefspace newBeliefspace) {
    beliefspace = newBeliefspace;
  }

  public void setHasDestinationCollector(Collector newHasDestinationCollector) {
    hasDestinationCollector = newHasDestinationCollector;
  }

  public void setNamespace(Namespace newNamespace) {
    namespace = newNamespace;
  }
  public void setId (int a_id) {
      if (a_id> -1) {
        id = a_id;
      }
  }

  public void setHasOutputContext(GraphContext newHasOutputContext) {
    hasOutputContext = newHasOutputContext;
  }

  /* to support remove operation on collections, java objs are equal if id match */
  public boolean equals(Object o) {
    if (!(o instanceof Channel)) //covers o == null case
      return false;
    Channel other = (Channel)o;
    if (this == other)
      return true;
    else
      return other.id == id;
  }

  /* to maintain hashCode contract */
  public int hashCode() {
    if (id == -1) {
      if (isPersistant()) {
        id = Workspace.makeGuid();
      } else {
        id = Workspace.nextId();
      }
    }
    return id;
  }

/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSON () {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Channel");
      jsonObj.put("id", id);
      if (getFilterNamespace() != null) {
        jsonObj.put("filterNamespace", getFilterNamespace().getId());
      }
      if (getBeliefspace() != null) {
        jsonObj.put("beliefspace", getBeliefspace().getId());
      }
      if (getHasDestinationCollector() != null) {
        jsonObj.put("hasDestinationCollector", getHasDestinationCollector().getId());
      }
      if (getNamespace() != null) {
        jsonObj.put("namespace", getNamespace().getId());
      }
      jsonObj.put("id", getId());
      if (getHasOutputContext() != null) {
        jsonObj.put("hasOutputContext", getHasOutputContext().getId());
      }
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to marshall data from caching layer object to JSON **/
  public JSONObject asJSONTree () {
    ConcurrentHashMap <DomainConcept, DomainConcept> written = new ConcurrentHashMap<DomainConcept, DomainConcept> ();
    return asJSONTreeAux(written);
  }
  public JSONObject asJSONTreeAux (ConcurrentHashMap<DomainConcept, DomainConcept> written) {
    JSONObject jsonObj = new JSONObject();
    try {
      jsonObj.put("class", "Channel");
      jsonObj.put("id", id);
      if (written.contains(this)) {
        return jsonObj;
      }
      written.put(this, this);
      if (getFilterNamespace() != null) {
        jsonObj.put("filterNamespace", getFilterNamespace().asJSONTreeAux(written));
      }
      if (getBeliefspace() != null) {
        jsonObj.put("beliefspace", getBeliefspace().asJSONTreeAux(written));
      }
      if (getHasDestinationCollector() != null) {
        jsonObj.put("hasDestinationCollector", getHasDestinationCollector().asJSONTreeAux(written));
      }
      if (getNamespace() != null) {
        jsonObj.put("namespace", getNamespace().asJSONTreeAux(written));
      }
      jsonObj.put("id", getId());
      if (getHasOutputContext() != null) {
        jsonObj.put("hasOutputContext", getHasOutputContext().asJSONTreeAux(written));
      }
      written.remove(this);
    } catch (Exception e1) {
      logWriter.error("Error in marshalling to JSON ", e1);
    }
    return jsonObj;
  }


/** method to update data in caching layer object from JSON **/
  public boolean updateFromJSON (JSONObject jsonObj) {
    try {
      if (!jsonObj.isNull("filterNamespace")) {
        int filterNamespaceId = jsonObj.optInt("filterNamespace");
        Namespace value = NamespaceManager.getInstance().get(filterNamespaceId);
        if(value != null) {
            setFilterNamespace(value);
        }
      }
      if (!jsonObj.isNull("beliefspace")) {
        int beliefspaceId = jsonObj.optInt("beliefspace");
        Beliefspace value = BeliefspaceManager.getInstance().get(beliefspaceId);
        if(value != null) {
            setBeliefspace(value);
        }
      }
      if (!jsonObj.isNull("hasDestinationCollector")) {
        int hasDestinationCollectorId = jsonObj.optInt("hasDestinationCollector");
        Collector value = CollectorManager.getInstance().get(hasDestinationCollectorId);
        if(value != null) {
            setHasDestinationCollector(value);
        }
      }
      if (!jsonObj.isNull("namespace")) {
        int namespaceId = jsonObj.optInt("namespace");
        Namespace value = NamespaceManager.getInstance().get(namespaceId);
        if(value != null) {
            setNamespace(value);
        }
      }
      if (!jsonObj.isNull("hasOutputContext")) {
        int hasOutputContextId = jsonObj.optInt("hasOutputContext");
        GraphContext value = GraphContextManager.getInstance().get(hasOutputContextId);
        if(value != null) {
            setHasOutputContext(value);
        }
      }
    } catch (Exception e) {
      logWriter.error("Failure updating from JSON", e);
      return false;
    }
    return true;
  }


  protected double weight = 1.0;
  protected HashMap<String, Double> filter = new HashMap<String, Double> ();
  protected Double defaultScore = 1.0;
  

 @Deprecated
 // Should not be used, a Channel needs an outputContext!
  public Channel(Collector aCollector, Namespace aNamespace, Beliefspace aBeliefspace, double aWeight) {
    hasDestinationCollector = aCollector;
    namespace = aNamespace;
    beliefspace = aBeliefspace;
    weight = aWeight;
  }

  public Channel(GraphContext anOutputContext, Collector aCollector, Namespace aNamespace, Beliefspace aBeliefspace, double aWeight) {
    hasDestinationCollector = aCollector;
    hasOutputContext = anOutputContext;
    namespace = aNamespace;
    beliefspace = aBeliefspace;
    weight = aWeight;
  }

  public Channel(GraphContext anOutputContext, Collector aCollector, double aWeight) {
    hasDestinationCollector = aCollector;
    hasOutputContext = anOutputContext;
    namespace = aCollector.getNamespace();
    beliefspace = aCollector.getBeliefspace();
    weight = aWeight;
  }

  public Channel(GraphContext anOutputContext, double aWeight) {
    hasDestinationCollector = anOutputContext.getHasSource();
    hasOutputContext = anOutputContext;
    namespace = anOutputContext.getInputNamespace();
    beliefspace = anOutputContext.getInputBeliefspace();
    weight = aWeight;
  }

  public void addFilterTerm(MapReduceItem term) {
    filter.put(term.getItem(), term.getScore());
  }

  /** set filter map to the given set of terms.  **/
  /** empty string is the default score for missing terms, permitting construction of leaky filters **/
  public void setFilterTerms(ArrayList<MapReduceItem> terms) {
    filter = new HashMap<String, Double>(terms.size());
    for (MapReduceItem term: terms) {
      if (term.getItem() == "") {
        defaultScore = term.getScore();
      }
      filter.put(term.getItem(), term.getScore());
    }
  }
  
  public void setDefaultFilterScore(double score) {
    defaultScore = score;
  }
    
  public double getDefaultFilterScore() {
    return defaultScore;
  }
  
  public double filter (MapReduceItem item) {
    if (filter == null || filter.size() == 0) {
      return 1.0;
    }
    ArrayList<MapReduceItem> mapping = abstractionMapping(item);
    double count = 0;
    double score = 1.0;
    for (MapReduceItem mappedToken: mapping) {
      count++;
      Double match = filter.get(mappedToken.getItem());
      if (match == null && filterNamespace != null) {// if we don't have a posterior for this term, use prior
        match = filterNamespace.getWeightedPrior(mappedToken.getItem());
      } 
      if (match != null) {
      score += Math.log(match);
      } else {
        score += Math.log(defaultScore);
      }
    }
    if (count == 0) {
      return 1.0;
    } else {
      return Math.exp(score/count);
    }
  }
  
  /** default abstraction is just the item itself **/
  public ArrayList<MapReduceItem> abstractionMapping(MapReduceItem item) {
    ArrayList<MapReduceItem> result = new ArrayList<MapReduceItem> (1);
    result.add(item);
    return result;
  }
  
  public void send(MapReduceItem item, double delta) {
    MapReduceItem targetNamespaceMRI = beliefspace.getMRI(item.getItem());
    double oldScore = targetNamespaceMRI.getScore();
    double mappedDelta = weight*filter(targetNamespaceMRI)*Math.min(delta, 1.0-oldScore); // can't propagate a change that raises belief over 1
    if (mappedDelta > 0) { 
      targetNamespaceMRI.setScore(oldScore+mappedDelta);
      hasDestinationCollector.collect(targetNamespaceMRI, mappedDelta);
    }
  }
  
  public void send(String item, double delta) {
    MapReduceItem targetNamespaceMRI = beliefspace.getMRI(item);
    double oldScore = targetNamespaceMRI.getScore();
    double mappedDelta = weight*filter(new MapReduceItem(item, delta))*Math.min(delta, 1.0-oldScore); // can't propagate a change that raises belief over 1
    if (mappedDelta > 0) { 
      targetNamespaceMRI.setScore(oldScore+mappedDelta);
      hasDestinationCollector.collect(targetNamespaceMRI, mappedDelta);
    }
  }
    
  public void send(ArrayList<MapReduceItem> items) {
    for (MapReduceItem item: items) {
      send(item.getItem(), item.getScore());
    }
  }


  
  
}
